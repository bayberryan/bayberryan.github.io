{"meta":{"title":"RickerYan","subtitle":null,"description":null,"author":"RickerYan","url":"http://yxqblog.tk"},"pages":[{"title":"about","date":"2017-03-25T05:25:52.000Z","updated":"2018-03-25T05:28:52.642Z","comments":true,"path":"about/index.html","permalink":"http://yxqblog.tk/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Git SSH 配置及使用","slug":"Git-SSH-配置及使用","date":"2017-07-14T16:00:00.000Z","updated":"2018-03-25T08:55:20.055Z","comments":true,"path":"2017/07/15/Git-SSH-配置及使用/","link":"","permalink":"http://yxqblog.tk/2017/07/15/Git-SSH-配置及使用/","excerpt":"","text":"在管理Git项目上，很多时候都是直接使用https url克隆到本地，当然也有有些人使用SSH url克隆到本地。 这两种方式的主要区别在于：使用https url克隆对初学者来说会比较方便，复制https url然后到git Bash里面直接用clone命令克隆到本地就好了，但是每次fetch和push代码都需要输入账号和密码，这也是https方式的麻烦之处。 而使用SSH url克隆却需要在克隆之前先配置和添加好SSH key，因此，如果你想要使用SSH url克隆的话，你必须是这个项目的拥有者。否则你是无法添加SSH key的，另外ssh默认是每次fetch和push代码都不需要输入账号和密码，如果你想要每次都输入账号密码才能进行fetch和push也可以另外进行设置。前面的几篇介绍Git的博客里面采用的都是https的方式作为案例， 今天主要是讲述如何配置使用ssh方式来提交和克隆代码。 大概可以分为一下几个步骤 设置Git的user name和email：(如果是第一次的话) 检查是否已经有SSH Key。 生成密钥 添加密钥到ssh-agent 登陆Github, 添加 ssh 测试： 设置Git的user name和email1234# 这里的“xujun&quot; 可以替换成自己的用户名git config --global user.name &quot;xujun&quot;# 这里的邮箱 gdutxiaoxu@163.com 替换成自己的邮箱git config --global user.email &quot;gdutxiaoxu@163.com&quot; 检查是否已经有SSH Key12cd ~/.sshls 列出该文件下的文件，看是否存在 id_isa 和 id_isa.pub 文件（也可以是别的文件名，只要 yourName 和 yourName.pub 承兑存在），如果存在的话，证明已经存在 ssh key了，可以直接跳过 生成密钥 这一步骤，下图是存在的情况 生成密钥12# 这里的邮箱 name@mail.com 替换成自己的邮箱ssh-keygen -t rsa -C &quot;name@mail.com&quot; 连续3个回车。如果不需要密码的话。最后得到了两个文件：id_rsa和id_rsa.pub。 默认的存储路径是： 1C:\\Users\\Administrator\\.ssh 添加密钥到ssh-agent确保 ssh-agent是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。 12# start the ssh-agent in the backgroundeval &quot;$(ssh-agent -s)&quot; 添加生成的 SSH key 到 ssh-agent。 1ssh-add ~/.ssh/id_rsa 登陆Github, 添加 ssh把id_rsa.pub文件里的内容复制到这里 测试：1ssh -T git@github.com 你将会看到： 1Hi humingx! You’ve successfully authenticated, but GitHub does not provide shell access. 如果看到Hi后面是你的用户名，就说明成功了。 扩展如果我之前的仓库是用https提交的，那么我现在想用ssh 的方式提交，怎么办呢 ，别急，下面就来教你怎样操作了。 这里同样以我本机目录下的G://test 仓库为例子， 找到仓库下 .git 文件夹下的config文件，打开，可以看到以下内容 12345678910111213[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote &quot;origin&quot;] url = https://github.com/yourname/test.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master 将文件中的 url = https://github.com/yourname/test.git 更改为 url = git@github.com:yourname/test.git 即可。 修改后的文件如下 12345678910111213[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote &quot;origin&quot;] url = git@github.com:gdutxiaoxu/test.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://yxqblog.tk/categories/版本控制/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yxqblog.tk/tags/Git/"},{"name":"Github","slug":"Github","permalink":"http://yxqblog.tk/tags/Github/"},{"name":"SSH","slug":"SSH","permalink":"http://yxqblog.tk/tags/SSH/"}]},{"title":"QT调用WebService的尝试和最终实现","slug":"cpp-call-webservice","date":"2017-06-20T16:00:00.000Z","updated":"2018-03-25T07:16:33.149Z","comments":true,"path":"2017/06/21/cpp-call-webservice/","link":"","permalink":"http://yxqblog.tk/2017/06/21/cpp-call-webservice/","excerpt":"","text":"最近接触的QT项目与平台对接时需要用到WebService。博主从毕业起大部分工作都是在做桌面开发，所以对WebService只能说是一知半解。唯一的接触就是在.NET平台下编写，发布和调用WebService。这其中大部分工作微软都帮我们做好了，我们只需添加web引用，就像引用本地的库一样。不得不说VS确实强大且易用性好。但是很多事情都是两面性的。就像现在习惯了vs的方便，当面临linux C++的WebService调用时，博主直接就懵逼了。闲话少说，进入正题。 最初的尝试 qtsoap 由于是QT项目，一向懒惰的博主首先想到的是去找QT下的开源方案。几番查找，找到了这个4、5年前的开源项目qtsoap。 通过官方示例和各种查阅文档。最终博主终于完成一个调用类，结构如下： 1234567891011121314151617181920212223242526272829303132333435#ifndef WEBSERVICE_H#define WEBSERVICE_H#include &lt;qtsoap.h&gt;class WebService:public QObject&#123; Q_OBJECTpublic: /********************************************** * description: Constructor * parameter: serviceUrl webservice url * opration request method * ********************************************/ WebService(QString serviceUrl,QString operation); ~WebService(); /************************************* * description: Submit Request * parameter: argument for operation * ***********************************/ void SubmitRequest(QString argument);private slots: /*********************************************** * description: Response after operation * parameter: responseMessage * *********************************************/ void getResponse(const QtSoapMessage &amp;response);private: //服务地址 QString serviceUrl; //执行的操作名称 QString operation; QtSoapHttpTransport http;&#125;; 只有两个函数：提交请求和获得响应，博主高高兴兴的编译 运行， 又是一脸懵，无论怎么检查，响应永远是Network transport error。没办法开始翻源码。当我看到要翻3000+行C++代码时，我的内心是拒绝的。 无奈之下改翻头文件，XMLschema和namespace深深的吸引了我 这地址1998和1999，主观上以我对自己的了解，我是不会再改这货了。最后还是去QT开源社区的群咨询了一下下。许久只得到了以下回复其余都是乱扯： 1qtsoap,我已经放弃了。 最后还是默默的关掉了项目，寻求其他方案。 进一步了解WebService和QNetworkAccessManager 无奈之下只能进一步开始了解WebService。什么是WebService呢？简单的说就是一种可以接受和相应网络上其他系统传递的请求，轻量的通讯技术，通过soap协议在web上提供服务。这里就不做详细解释了，想了解的同学可以自行搜索或参阅文末链接。基于对WebService的进一步了解，也就是说我们只需要通过网络向WebService发送soap消息请求就可以了。于是下一步就是解决QT下的网络通信了。于是主角QNetworkAccessManager登场。在了解了如何使用QNetworkAccessManager发送post和get请求后懒癌晚期的还是选择了寻找现成的方法。最后找到了这个：QNetworkAccessManager调用WebService 因为目标WebService需要客户端传递xml格式的字符串，博主在以上方案上修改了部分代码又加了两个函数。源码奉上： 头文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** ***************************************************** * QWebService * * 通过http post或get请求调用WebService * * ******************************************************/#ifndef QWEBSERVICE_H#define QWEBSERVICE_H#include &lt;QTimer&gt;#include &lt;QThread&gt;#include &lt;QNetworkAccessManager&gt;#include &lt;QNetworkRequest&gt;#include &lt;QNetworkReply&gt;/** * xml字符串，转义符替换。 **/void Xml2Esc(QString &amp;xmlString);void Esc2Xml(QString &amp;escString);class NetDataListenerThread:public QThread&#123; Q_OBJECTpublic: NetDataListenerThread(QNetworkAccessManager *manager,QNetworkReply * reply,int timeoutms,QObject *parent = 0); ~NetDataListenerThread(); QByteArray getBa() const; bool getIsWaitTimeOut() const;protected: virtual void run();private: bool waitForConnect();protected slots: void slot_waitTimeout();signals: void sig_waitTimeout();private: QNetworkAccessManager *mManager; int m_TimeOutms; bool m_waitTimeOut; bool m_isWaitTimeOut; QNetworkReply * m_reply;&#125;;/** * @brief The WebServiceHelp class webservice调用帮助类 * @author zp */class WebServiceHelp:public QObject&#123; Q_OBJECTprivate: QString postXml = &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;utf-8\\&quot;?&gt;&lt;soap:Envelope xmlns:xsi=\\&quot;http://www.w3.org/2001/XMLSchema-instance\\&quot; xmlns:xsd=\\&quot;http://www.w3.org/2001/XMLSchema\\&quot; xmlns:soap=\\&quot;http://schemas.xmlsoap.org/soap/envelope/\\&quot;&gt;&lt;soap:Body&gt;&lt;toTraditionalChinese xmlns=\\&quot;http://webxml.com.cn/\\&quot;&gt;&lt;sText&gt;ARGUMENT&lt;/sText&gt;&lt;/toTraditionalChinese&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;&quot;; class Dispose &#123; public: ~Dispose(); &#125;;public: static WebServiceHelp * getInstance();public: /** * @brief sendGetRequest 发送Get请求 * @param urlStr url * @param ba 返回数据 * @param timeOutms 超时时间 * @return 返回错误代码 */ QNetworkReply::NetworkError sendGetRequest(QString urlStr, QByteArray &amp; ba, int timeOutms=3000); /** * @brief sendPostRequest 发送post请求 * @param website 网址 * @param methodName 方法名称 * @param param 参数 * @param postBa post数据 * @param code 返回代码 * @param message 返回信息 * @param data 返回数据 * @param timeOutms 超时时间 * @return 返回错误代码 */ QNetworkReply::NetworkError sendPostRequest(QString website,const QString argument, QByteArray&amp; retBa, int timeOutms=3000);protected slots: void slot_error(QNetworkReply::NetworkError code);private: static WebServiceHelp * serverHelp; static WebServiceHelp::Dispose disp; QNetworkAccessManager *manager; QNetworkReply::NetworkError m_errCode;private: WebServiceHelp(QObject *parent=0); ~WebServiceHelp();&#125;;#endif // QWEBSERVICE_H 类文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172 #include &quot;qwebservice.h&quot;#include &lt;QEventLoop&gt;NetDataListenerThread::NetDataListenerThread(QNetworkAccessManager *manager, QNetworkReply *reply, int timeoutms, QObject *parent) :QThread(parent),mManager(manager),m_TimeOutms(timeoutms),m_reply(reply)&#123; m_waitTimeOut = false; m_isWaitTimeOut = false;&#125;NetDataListenerThread::~NetDataListenerThread()&#123;&#125;void NetDataListenerThread::run()&#123; m_isWaitTimeOut = waitForConnect();&#125;bool NetDataListenerThread::waitForConnect()&#123; QEventLoop eventLoop; QTimer * timer = NULL; m_waitTimeOut = false; bool bWaitTimeOut = false; if (m_TimeOutms &gt; 0) &#123; timer = new QTimer; connect(timer, SIGNAL(timeout()), this, SLOT(slot_waitTimeout())); timer-&gt;setSingleShot(true); timer-&gt;start(m_TimeOutms); connect(this, SIGNAL(sig_waitTimeout()), &amp;eventLoop, SLOT(quit())); &#125; connect(mManager, SIGNAL(finished(QNetworkReply *)), &amp;eventLoop, SLOT(quit())); if (m_reply != NULL) &#123; connect(m_reply, SIGNAL(readyRead()), &amp;eventLoop, SLOT(quit())); &#125; eventLoop.exec(); if (timer != NULL) &#123; timer-&gt;stop(); delete timer; timer = NULL; &#125; bWaitTimeOut = m_waitTimeOut; m_waitTimeOut = false; return !bWaitTimeOut;&#125;void NetDataListenerThread::slot_waitTimeout()&#123; m_waitTimeOut = true; emit sig_waitTimeout();&#125;bool NetDataListenerThread::getIsWaitTimeOut() const&#123; return m_isWaitTimeOut;&#125;WebServiceHelp * WebServiceHelp::serverHelp = NULL;WebServiceHelp::Dispose WebServiceHelp::disp;WebServiceHelp::WebServiceHelp(QObject *parent):QObject(parent)&#123; manager = new QNetworkAccessManager(); m_errCode= QNetworkReply::NoError;&#125;WebServiceHelp::~WebServiceHelp()&#123; manager-&gt;deleteLater();&#125;WebServiceHelp *WebServiceHelp::getInstance()&#123; if(serverHelp==NULL) &#123; serverHelp = new WebServiceHelp(); &#125; return serverHelp;&#125;QNetworkReply::NetworkError WebServiceHelp::sendGetRequest(QString urlStr, QByteArray &amp; ba,int timeOutms)&#123; QNetworkReply::NetworkError retError = QNetworkReply::NoError; m_errCode= QNetworkReply::NoError; QNetworkRequest request; QUrl url(urlStr); request.setUrl(url); QNetworkReply *reply = manager-&gt;get(request); connect(reply,static_cast&lt;void (QNetworkReply::*)(QNetworkReply::NetworkError)&gt;(&amp;QNetworkReply::error),this,&amp;WebServiceHelp::slot_error); QEventLoop eventLoop; NetDataListenerThread * thread = new NetDataListenerThread(manager,reply,timeOutms); connect(thread, &amp;NetDataListenerThread::finished,&amp;eventLoop,&amp;QEventLoop::quit); thread-&gt;start(); eventLoop.exec(); if(thread-&gt;getIsWaitTimeOut()) &#123; ba = reply-&gt;readAll(); &#125; else &#123; m_errCode=QNetworkReply::TimeoutError; &#125; thread-&gt;deleteLater(); delete reply; delete thread; thread = NULL; retError = m_errCode; m_errCode= QNetworkReply::NoError; return retError;&#125;QNetworkReply::NetworkError WebServiceHelp:: sendPostRequest(QString website, const QString argument, QByteArray &amp;retBa, int timeOutms)&#123; QString urlStr =website; QByteArray postBa=postXml.replace(&quot;ARGUMENT&quot;,argument).toUtf8(); qDebug()&lt;&lt;postBa; QNetworkReply::NetworkError retError = QNetworkReply::NoError; m_errCode= QNetworkReply::NoError; QNetworkRequest request; QSslConfiguration config; config.setPeerVerifyMode(QSslSocket::VerifyNone); config.setProtocol(QSsl::TlsV1SslV3); request.setSslConfiguration(config); QUrl url(urlStr); request.setUrl(url); request.setHeader(QNetworkRequest::ContentTypeHeader,&quot;text/xml; charset=utf-8&quot;); request.setHeader(QNetworkRequest::ContentLengthHeader,postBa.length()); QNetworkReply *reply = manager-&gt;post(request,postBa); connect(reply,static_cast&lt;void (QNetworkReply::*)(QNetworkReply::NetworkError)&gt;(&amp;QNetworkReply::error),this,&amp;WebServiceHelp::slot_error); QEventLoop eventLoop; NetDataListenerThread * thread = new NetDataListenerThread(manager,reply,timeOutms); connect(thread, &amp;NetDataListenerThread::finished,&amp;eventLoop,&amp;QEventLoop::quit); thread-&gt;start(); eventLoop.exec(); if(thread-&gt;getIsWaitTimeOut()) &#123; retBa = reply-&gt;readAll(); &#125; else &#123; m_errCode=QNetworkReply::TimeoutError; &#125; thread-&gt;deleteLater(); delete reply; delete thread; thread = NULL; retError = m_errCode; m_errCode= QNetworkReply::NoError; return retError;&#125;void WebServiceHelp::slot_error(QNetworkReply::NetworkError code)&#123; m_errCode = code;&#125;WebServiceHelp::Dispose::~Dispose()&#123; if(WebServiceHelp::serverHelp!=NULL) &#123; delete WebServiceHelp::serverHelp; WebServiceHelp::serverHelp=NULL; &#125;&#125;void Xml2Esc(QString &amp;xmlString)&#123; xmlString.replace(&quot;&lt;&quot;,&quot;&amp;lt;&quot;); xmlString.replace(&quot;&gt;&quot;,&quot;&amp;gt;&quot;); xmlString.replace(&quot;&amp;&quot;,&quot;&amp;amp;&quot;); xmlString.replace(&quot;&apos;&quot;,&quot;&amp;apos;&quot;); xmlString.replace(&quot;\\&quot;&quot;,&quot;&amp;quot;&quot;);&#125;void Esc2Xml(QString &amp;escString)&#123; escString.replace(&quot;&amp;lt;&quot;,&quot;&lt;&quot;); escString.replace(&quot;&amp;gt;&quot;,&quot;&gt;&quot;); escString.replace(&quot;&amp;amp;&quot;,&quot;&amp;&quot;); escString.replace(&quot;&amp;apos;&quot;,&quot;&apos;&quot;); escString.replace(&quot;&amp;quot;&quot;,&quot;\\&quot;&quot;);&#125; 这样我们只需在项目加入以上代码，直接调用函数发送请求就ok了 1QNetworkReply::NetworkError ret=WebServiceHelp::getInstance()-&gt;sendPostRequest(url,argement,retba); 最终的选择 gsoap 虽然博主已经通过发送post请求实现了WebService的调用，但开会时平台方还是建议用gsoap实现WebService服务或调用WebService。最终博主还是默默的将gsoap下载下来。默默的查了查C++的调用方法。然后默默的将项目替换成使用gsoap调用WebService。 关于gsoap的C++使用方法博主会有单独的文章介绍。今天就先写到这里，出差在宾馆写这些已经很佩服我自己了。继续加油吧。。。 附链 qtsoap WebService工作原理 QNetworkAccessManager gsoap","categories":[{"name":"QT","slug":"QT","permalink":"http://yxqblog.tk/categories/QT/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://yxqblog.tk/tags/QT/"},{"name":"C++","slug":"C","permalink":"http://yxqblog.tk/tags/C/"},{"name":"qtsoap","slug":"qtsoap","permalink":"http://yxqblog.tk/tags/qtsoap/"},{"name":"gsoap","slug":"gsoap","permalink":"http://yxqblog.tk/tags/gsoap/"},{"name":"WebService","slug":"WebService","permalink":"http://yxqblog.tk/tags/WebService/"}]},{"title":"ArcMap面要素处理之平滑面(Smooth Polygon)","slug":"ArcMap-Ploygon-Smooth","date":"2017-06-14T16:00:00.000Z","updated":"2018-03-25T09:21:53.067Z","comments":true,"path":"2017/06/15/ArcMap-Ploygon-Smooth/","link":"","permalink":"http://yxqblog.tk/2017/06/15/ArcMap-Ploygon-Smooth/","excerpt":"","text":"摘要创建一个新的输出要素类，包含从输入面上删除某些指定大小的部分或孔洞所得的要素。 插图 用法 有两种平滑方法可供选择： PAEK（指数核的多项式近似）方法可根据平滑容差对面进行平滑处理。每个面经过平滑处理后，其折点都可能比之前多。平滑容差参数可控制计算新折点时用到的“移动”路径的长度。长度越短，保留的细节越多，处理时间也越长。 贝塞尔插值方法（Python 中为 BEZIER_INTERPOLATION）对面进行平滑处理时无需使用容差，而是通过创建贝塞尔曲线来匹配输入线。如果输出为 shapefile，则将创建近似的贝塞尔曲线，因为真正的贝塞尔曲线无法存储在 shapefile 中。 平滑处理可能带来拓扑错误，如面轮廓的交叉。使用处理拓扑错误参数中的标记错误选项（Python 中为 FLAG_ERRORS）可识别这些错误。将添加两个字段 InPoly_FID 和 SmoPlyFlag 以包含输入要素 ID 和拓扑错误。SmoPlyFlag 字段中的值为 1 表明存在拓扑错误；0（零）表明不存在错误。InPoly_FID 字段将输出面连接到其输入面。标记错误选项不能在编辑会话中使用。 在平滑处理的过程中，可能创建无效（自相交）的几何，并将对无效的几何进行修复，但不会将其改进。例如，如果一个面自交叉，则这个面将成为多部分面，但显示效果依然是自交叉。 语法1SmoothPolygon_cartography (in_features, out_feature_class, algorithm, tolerance, &#123;endpoint_option&#125;, &#123;error_option&#125;) 参数 说明 数据类型 in_features 要平滑处理的面要素。 Feature Layer out_feature_class 要创建的输出面要素类。 Feature Class algorithm 指定平滑算法。PAEK —Polynomial Approximation with Exponential Kernel（指数核的多项式近似）的首字母缩略词。该方法可以计算不经过输入面折点的平滑面。这是默认设置。BEZIER_INTERPOLATION —拟合折点间的贝塞尔曲线。生成的面将经过输入面的折点。该算法不需要容差。在 shapefile 输出中，将创建近似的贝塞尔曲线。 String tolerance 设置 PAEK 算法使用的容差。必须指定一个容差，且值必须大于零。可以指定首选单位；默认为要素单位。使用 BEZIER_INTERPOLATION 平滑算法时，必须输入 0 作为占位符。 Linear Unit endpoint_option(可选) 指定是否保留孤立面环的端点。该选项仅适用于 PAEK 算法。FIXED_ENDPOINT —保留孤立面环的端点。这是默认设置。NO_FIXED —通过孤立面环的端点进行平滑处理。 Boolean error_option(可选) 指定如何处理拓扑错误（可能是在该过程中引发的，如线的交叉或重叠）。NO_CHECK —指定不检查拓扑错误。这是默认设置。FLAG_ERRORS —指定标记拓扑错误（如果发现拓扑错误）。 String 代码实例平滑面示例（Python 窗口）以下 Python 窗口脚本演示了如何在即时模式下使用“平滑面”工具。 1234import arcpyimport arcpy.cartography as CAarcpy.env.workspace = &quot;C:/data&quot;CA.SmoothPolygon(&quot;soils.shp&quot;, &quot;C:/output/output.gdb/smoothed_soils&quot;, &quot;PAEK&quot;, 100) 平滑面示例 2（独立脚本）以下独立 Python 脚本演示了如何使用“简化面”工具。 123456789101112131415161718192021222324# Name: SmoothPolygon_Example2.py# Description: Eliminate small islands before simplifying and smoothing lake boundaries # Import system modulesimport arcpyimport arcpy.cartography as CAimport arcpy.management as DM # Set environment settingsarcpy.env.workspace = &quot;C:/data/Portland.gdb/Hydrography&quot; # Set local variablesinLakeFeatures = &quot;lakes&quot;eliminatedFeatures = &quot;C:/data/PortlandOutput.gdb/lakes_eliminated&quot;simplifiedFeatures = &quot;C:/data/PortlandOutput.gdb/lakes_simplified&quot;smoothedFeatures = &quot;C:/data/PortlandOutput.gdb/lakes_smoothed&quot;# Eliminate small islands in lake polygons.DM.EliminatePolygonPart(inLakeFeatures, eliminatedFeatures, 100, &quot;OR&quot;, 0, &quot;CONTAINED_ONLY&quot;) # Simplify lake polygons.CA.SimplifyPolygon(eliminatedFeatures, simplifiedFeatures, &quot;POINT_REMOVE&quot;, 50, 200, &quot;RESOLVE_ERRORS&quot;, &quot;KEEP_COLLAPSED_POINTS&quot;, &quot;CHECK&quot;) # Smooth lake polygons.CA.SmoothPolygon(simplifiedFeatures, smoothedFeatures, &quot;PAEK&quot;, 100, &quot;&quot;, &quot;FLAG_ERRORS&quot;) 了解更多要了解更多关于ArcMap的知识请参阅以下链接： desktop.arcgis.com","categories":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/categories/ArcMap/"}],"tags":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/tags/ArcMap/"},{"name":"Polygon","slug":"Polygon","permalink":"http://yxqblog.tk/tags/Polygon/"},{"name":"Gp","slug":"Gp","permalink":"http://yxqblog.tk/tags/Gp/"}]},{"title":"使用MVVM模式开发Arcgis Runtime 程序","slug":"use-mvvm-in-ArcgisRuntime-app","date":"2017-05-25T16:00:00.000Z","updated":"2018-03-25T07:16:42.876Z","comments":true,"path":"2017/05/26/use-mvvm-in-ArcgisRuntime-app/","link":"","permalink":"http://yxqblog.tk/2017/05/26/use-mvvm-in-ArcgisRuntime-app/","excerpt":"","text":"MVVM介绍MVVM是XAML程序开发中常用的设计模式，能够实现用户界面和数据、业务逻辑的完全分离。为实现分离MVVM将程序分割为以下三个类别。 Model - 程序中使用的数据模型。 View - 用户界面。 ViewModel-处理Model中的数据并为View提供业务逻辑。 理想的MVVM程序中，组件必须完全包含在这三个类别中。比如XAML页面中不应包含代码，同样所有与视图不直接相关的代码都必须由ViewModel提供。数据绑定提供了支持在WPF中，Windows商店和Windows Phone应用程序允许使用XAML定义UI和将控件与视图ViewModel类所需的数据和功能绑定。 一般来说，使用MVVM创建程序时，我们的大部分时间都花在ViewModel上。这些类提供提供界面使用的数据。ViewModel也可能包含处理用户界面事件和其他View需要的业务逻辑。 MVVM模式文档很完备。该教程不是为讲述MVVM模式，而是介绍在其ArcGisRun Runtime SDK for .NET开发中的使用。要了解更多关于MVVM的内容，请参阅文末链接。 先决条件该教程需要Microsoft Visual Studio和 ArcGIS Runtime SDK for .NET.SDK安装和系统需求请参阅以下链接installing the SDK and system requirements. 需要了解 Visual Studio, XAML, and C# 。 创建WPF程序使用Visual Studio创建一个WPF程序。 打开Visual Studio。 选择文件&gt;新建&gt;项目创建一个新的项目。 在新建项目界面选择Windows Desktop &gt; WPF 程序 提示：ArcGIS Runtime SDK for .NET 提供了项目模板：ArcGIS Runtime 10.2.7 for .NET App使用模板创建项目会自动添加引用和带有mapvew的主页面。 选择项目路径修改项目名称为MvvmApp。 点击确定创建项目。 右击项目下的引用添加Esri.ArcGISRuntime引用。 Esri.ArcGISRuntime.dll包含mapcontrol和要用到的所有核心API。 添加Map本程序将加载ArcGIS Online 的影像底图和一个点图层。定义点的渲染方式和当前的视图范围。 在XAML designer中使用ArcGISRuntime需要添加命名空间。 在设计器中打开主页面MainWindow.xaml. 添加以下命名空间 1xmlns:esri=&quot;http://schemas.esri.com/arcgis/runtime/2013&quot; 在标签下添加以下xaml代码 12345678910111213141516171819&lt;esri:MapView x:Name=&quot;MyMapView&quot;&gt; &lt;esri:Map&gt; &lt;esri:Map.InitialViewpoint&gt; &lt;esri:ViewpointExtent XMin=&quot;-1631122.453&quot; YMin=&quot;4253523.549&quot; XMax=&quot;4163264.136&quot; YMax=&quot;8976345.495&quot; /&gt; &lt;/esri:Map.InitialViewpoint&gt; &lt;esri:ArcGISTiledMapServiceLayer ID=&quot;BaseMap&quot; ServiceUri=&quot;http://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer&quot;/&gt; &lt;esri:FeatureLayer ID=&quot;Incidents&quot;&gt; &lt;esri:ServiceFeatureTable ServiceUri=&quot;http://sampleserver6.arcgisonline.com/arcgis/rest/services/SF311/FeatureServer/0&quot;/&gt; &lt;esri:FeatureLayer.Renderer&gt; &lt;esri:SimpleRenderer&gt; &lt;esri:SimpleMarkerSymbol Color=&quot;Red&quot; Size=&quot;16&quot; Style=&quot;Triangle&quot;/&gt; &lt;/esri:SimpleRenderer&gt; &lt;/esri:FeatureLayer.Renderer&gt; &lt;/esri:FeatureLayer&gt; &lt;esri:GraphicsLayer ID=&quot;PointGraphics&quot;/&gt; &lt;/esri:Map&gt;&lt;/esri:MapView&gt; 编译运行界面如下图。 移除地图数据为了将界面与数据和逻辑分离，我们移除mapview中的map。将其存储在程序的资源字典中，并使用数据绑定显示到界面。 选择esri:MapView标签下的所有内容》剪切。 打开App.xaml文件。 将剪切的代码粘贴到&lt;Application.Resources&gt;标签下。 12345678910111213141516171819202122&lt;Application.Resources&gt; &lt;esri:Map&gt; &lt;esri:Map.InitialViewpoint&gt; &lt;esri:ViewpointExtent XMin=&quot;-1631122.453&quot; YMin=&quot;4253523.549&quot; XMax=&quot;4163264.136&quot; YMax=&quot;8976345.495&quot; /&gt; &lt;/esri:Map.InitialViewpoint&gt; &lt;esri:ArcGISTiledMapServiceLayer ID=&quot;BaseMap&quot; ServiceUri=&quot;http://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer&quot;/&gt; &lt;esri:FeatureLayer ID=&quot;Incidents&quot;&gt; &lt;esri:ServiceFeatureTable ServiceUri=&quot;http://sampleserver6.arcgisonline.com/arcgis/rest/services/SF311/FeatureServer/0&quot;/&gt; &lt;esri:FeatureLayer.Renderer&gt; &lt;esri:SimpleRenderer&gt; &lt;esri:SimpleMarkerSymbol Color=&quot;Red&quot; Size=&quot;16&quot; Style=&quot;Triangle&quot;/&gt; &lt;/esri:SimpleRenderer&gt; &lt;/esri:FeatureLayer.Renderer&gt; &lt;/esri:FeatureLayer&gt; &lt;esri:GraphicsLayer ID=&quot;PointGraphics&quot;/&gt; &lt;/esri:Map&gt;&lt;/Application.Resources&gt; 添加ArcgisRuntime命名空间。 给map添加x:Key属性并赋值IncidentMap。 1&lt;esri:Map x:Key=&quot;IncidentMap&quot;&gt; x:Key 用与识别资源，作用范围内值应唯一 返回主页面添加代码将IncidentMap资源绑定到mapview 12&lt;esri:MapView x:Name=&quot;MyMapView&quot; Map=&quot;&#123;Binding Source=&#123;StaticResource IncidentMap&#125;&#125;&quot;&gt; &lt;/esri:MapView&gt; 地图属性的数据绑定使用绑定标记扩展在XAML中指定。可以绑定应用程序中的资源，页面上的其他元素，或应用程序中提供数据的类。在XAML应用程序中对数据绑定的更多信息可以参阅数据绑定概述（MSDN）.aspx)。 编译运行，程序与之前相同。 我们的程序现在实现MVVM模式了吗？还不是最理想的形式，app.xaml页面作为一个视图模型提供了一个可以绑定的地图。这说明使用该模式的优势之一，它清楚地将UI与实现细节分开。MapView是UI控件，属于页面。它包含的地图和图层是控件中显示的数据，该数据需要更改，并且应在UI之外进行管理。有了这个架构，页面和地图是松散耦合的，这意味着你可以很容易地改变一个不影响另一个。若要更改页中显示的地图，只需将绑定指向应用程序中可用的其他资源。 为实现传统形式的MVVM模式，我们需要创建一个ViewModel类来充当页面的数据上下文，并公开用户界面可以绑定的数据和功能。 创建一个ViewModel类ViewModel提供视图可以通过数据绑定访问的数据和功能。一个视图对应一个视图模型是很常见的，但是多个些视图模型与单个视图关联并不多见。我们也可以有一个视图模型，该模型被应用程序中的几个不同视图使用。我们将创建一个单一的视图模型（mapviewmodel）提供的所有页面需要的数据和功能。 右击项目》添加类：MapViewModel.cs. 添加引用 12using Esri.ArcGISRuntime.Controls;using Esri.ArcGISRuntime.Layers; 添加新的属性：IncidentMap。 123456private Map map;public Map IncidentMap&#123; get &#123; return this.map; &#125; set &#123; this.map = value; &#125;&#125; IncidentMap属性提供视图需要绑定的数据。 添加构造函数、初始化地图 12345public MapViewModel()&#123; // when the view model initializes, read the map from the App.xaml resources this.map = App.Current.Resources[&quot;IncidentMap&quot;] as Map;&#125; 绑定ViewModel到View为了关联ViewModel和View，我们需要将View的DataContext属性设置为ViewModel的一个实例。可以使用xaml或view的codebehind设置。以下步骤使用xaml将viewmodel中的incidentmap绑定到view中mapview的map属性 打开app.xaml。添加本地程序集xaml命名空间 123456&lt;Application x:Class=&quot;MvvmApp.App&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:esri=&quot;http://schemas.esri.com/arcgis/runtime/2013&quot; xmlns:local=&quot;clr-namespace:MvvmApp&quot; StartupUri=&quot;MainWindow.xaml&quot;&gt; 在Application.Resources 标签IncidentMap定义后添加xanl定义一个MapViewModel对象并赋值X:key为MapVM 1&lt;local:MapViewModel x:Key=&quot;MapVM&quot;/&gt; 打开MainWindow.xaml 设置整个页面的DataContext绑定MapVM对象。 123456&lt;Window x:Class=&quot;MvvmApp.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:esri=&quot;http://schemas.esri.com/arcgis/runtime/2013&quot; Title=&quot;MainWindow&quot; Height=&quot;350&quot; Width=&quot;525&quot; DataContext=&quot;&#123;Binding Source=&#123;StaticResource MapVM&#125;&#125;&quot;&gt; 一旦ViewModel设置为整个页面的DataContext，页面上的任一控件都可绑定ViewModel暴露出的属性。 修改mapview的绑定声明。 12&lt;esri:MapView x:Name=&quot;MyMapView&quot; Map=&quot;&#123;Binding IncidentMap&#125;&quot;&gt; &lt;/esri:MapView&gt; 编译运行，地图和在页面中直接定义时相同。 使用这种模式显示地图的优势是什么？无论我们在哪里定义地图，应用程序看起来都是一样的，但使用ViewModel似乎增加了很多复杂性。对于这样一个简单的应用程序，使用MVVM模式的确没有优势。但当应用程序变得更加复杂时，你会发现MVVM架构使应用程序更容易维护并促进应用程序之间共享代码。 在ViewModel中处理点击事件在视图模型中保存数据并将其绑定到UI很简单，但是关于视图函数和功能呢？ 如果完全实现MVVM模式，所有的业务逻辑都应包含在ViewModel中。页面的codebehind也不应包含事件代码。幸运的是，数据绑定还可以将View中的控件事件绑定到ViewModel中的代码。 执行Command一些控件，如按钮、复选框、单选按钮和菜单项，提供了一个Command属性。Command是自定义类，实现ICommand接口。定义当一个控件点击时的事件（执行方法），并确定何时应该启用（执行方法）。可以在视图模型中创建Command，并绑定到相应控件的Command属性。 提示：现在有很多MVVM的框架提供了ICommand的实现。使用这些框架时，我们可以在视图模型中实例化命令对象，而不必创建本节所描述的自己的命令类的中间步骤。如果计划广泛使用MVVM，可以考虑使用框架开发应用程序，如MVVMLight。 新建类并命名DelegateCommand.cs。 添加命名空间System.Windows.Input 1using System.Windows.Input; 在 DelegateCommand类中实现Icommand接口。完整的实现代码如下： 1234567891011121314151617181920212223242526272829303132class DelegateCommand : System.Windows.Input.ICommand&#123; // a var to store the command&apos;s execute logic (button click, for example) private readonly Action&lt;object&gt; execute; // a var to store the command&apos;s logic for enabling/disabling private readonly Func&lt;object, bool&gt; canExecute; // an event for when the value of &quot;CanExecute&quot; changes (not implemented) public event EventHandler CanExecuteChanged; // constructor: store the logic for executing and enabling the command public DelegateCommand(Action&lt;object&gt; executeAction, Func&lt;object, bool&gt; canExecuteFunc = null) &#123; this.canExecute = canExecuteFunc; this.execute = executeAction; &#125; // if it was passed in, execute the enabling logic for the command public bool CanExecute(object parameter) &#123; if (this.canExecute == null) &#123; return true; &#125; return this.canExecute(parameter); &#125; // execute the command logic public void Execute(object parameter) &#123; this.execute(parameter); &#125;&#125; 当需要绑定一个按钮和命令时，创建一个delegatecommand实例传递事件命令的执行和控件到构造函数。执行操作的参数是object类型，以给命令提供最大的灵活性。 保存和关闭DelegateCommand.cs。 在ViewModel中创建Command属性任何需要绑定的内容都必须是public的属性。下一步我们将创建MapViewModel的一个新属性返回一个DelegateCommand 对象。该命令被定义为执行和启用逻辑，因此它可以绑定到视图中的按钮。 打开MapViewModel类定义一个public属性：ToggleLayerCommand 返回一个DelegateCommand对象。 1public DelegateCommand ToggleLayerCommand &#123; get; set; &#125; 创建一个新的函数响应命令执行，命名togglelayer。该函数控制map中图层的可见性。输入参数指定要修改的图层名称。 123456private void ToggleLayer(object parameter)&#123; var lyr = this.map.Layers[parameter.ToString()]; lyr.IsVisible = !(lyr.IsVisible); &#125; 创建另一个新的函数来确定Command的执行状态。由于命令修改一个特定的图层，只有当图层存在时才可执行。参数与上一个函数相同。 12345private bool OkToExecute(object parameter)&#123; var lyr = this.map.Layers[parameter.ToString()] as FeatureLayer; return (lyr != null);&#125; 如果指定名称的图层不存在，oktoexecute返回false，禁用相关的控件。 在mapviewmodel的构造函数，添加以下代码行来实例化togglelayercommand。传递thetogglelayer函数作为命令的执行逻辑、oktoexecute为enable逻辑。 123456public MapViewModel()&#123; // when the view model initializes, read the map from the App.xaml resources this.map = MvvmApp.App.Current.Resources[&quot;IncidentMap&quot;] as Map; ToggleLayerCommand = new DelegateCommand(ToggleLayer, OkToExecute);&#125; ##绑定一个button到ViewModel的Command 按钮提供一个可执行代码的单击事件。指定一个Command定义按钮单击的代码，它的优点是还包含了指示按钮何时启用或禁用的逻辑。一个按钮对象的Command属性都可以绑定到实现ICommand接口的对象。 在MainWindow.xaml 页面添加一个新的button 123&lt;Button Height=&quot;30&quot; Width=&quot;70&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Bottom&quot; Content=&quot;Toggle&quot; /&gt; 设置button的Command属性绑定到view model的ToggleLayerCommand属性。 1234&lt;Button Height=&quot;30&quot; Width=&quot;70&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Bottom&quot; Content=&quot;Toggle&quot; Command=&quot;&#123;Binding ToggleLayerCommand&#125;&quot;/&gt; 设置按钮的commandparameter属性值，为Command提供参数。 12345&lt;Button Height=&quot;30&quot; Width=&quot;70&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Bottom&quot; Content=&quot;Toggle&quot; Command=&quot;&#123;Binding ToggleLayerCommand&#125;&quot; CommandParameter=&quot;Incidents&quot;/&gt; 编译运行，点击Toggle按钮控制incidents图层的可见性。 在ViewModel中处理其他事件前面描述的视图模型中绑定命令的过程适用于提供所需命令属性的控件。如果需要处理其他不能直接使用命令属性绑定的事件，该怎么办？幸运的是，.NET提供了额外的类，可以将视图中的事件绑定到视图模型中的命令或函数。 在下面的步骤中，将使用system.windows.interactivity的类来处理MapView的ExtentChanged事件。 选择**项目》添加引用，添加System.Windows.Interactivity引用 提示：如果引用不存在需要安装Microsoft Expression Blend SDK.或在NuGet中搜索“blend”下载。 打开MainWindow.xaml在标签内添加以下xaml命名空间。 1xmlns:interactivity=&quot;http://schemas.microsoft.com/expression/2010/interactivity&quot; MapView 标签下添加以下xaml定义ExtentChanged事件的触发器。 1234567&lt;esri:MapView x:Name=&quot;MyMapView&quot; Map=&quot;&#123;Binding IncidentMap&#125;&quot;&gt; &lt;interactivity:Interaction.Triggers&gt; &lt;interactivity:EventTrigger EventName=&quot;ExtentChanged&quot;&gt; &lt;/interactivity:EventTrigger&gt; &lt;/interactivity:Interaction.Triggers&gt;&lt;/esri:MapView&gt; 可以使用一个函数（方法）或一个命令对象来响应事件。因为需要一个参数（MapView），所以使用command并提供一个CommandParameter将当前视图范围传递到view model 添加以下xaml定义InvokeCommandAction响应事件。ViewModel中还不存在ExtentChangedCommand，我们稍后创建。 123&lt;interactivity:InvokeCommandAction Command=&quot;&#123;Binding ExtentChangedCommand&#125;&quot; CommandParameter=&quot;&#123;Binding ElementName=MyMapView&#125;&quot;/&gt; 打开MapViewModel.cs添加以下代码定义一个DelegateCommand对象并命名为ExtentChangedCommand 1public DelegateCommand ExtentChangedCommand &#123; get; set; &#125; 添加以下函数响应视图范围改变。现在需要确保能获取到 mapview的视图范围。 123456public void MyMapViewExtentChanged(object parameter)&#123; var mv = parameter as MapView; var extent = mv.Extent;&#125; 在构造函数中添加以下代码实例化ExtentChangedCommand. 1234567public MapViewModel()&#123; // when the view model initializes, read the map from the App.xaml resources this.map = MvvmApp.App.Current.Resources[&quot;IncidentMap&quot;] as Map; ToggleLayerCommand = new DelegateCommand(ToggleLayer, OkToExecute); ExtentChangedCommand = new DelegateCommand(MyMapViewExtentChanged);&#125; DelegateCommand中的是否可执行逻辑是可选的，所以我们没有指定它。 在MyMapViewExtentChanged函数最后一行添加断点，运行程序，看是否命中断点查看获取的mapview范围。测试完毕后移除断点。 至此我们已经完成了在ViewModel中处理视图范围更改事件的绑定。以上过程可以用来处理所有界面控件的事件，包括不提供Command属性的控件。 绑定视图的范围值要在应用程序中显示当前范围的坐标，需要在ViewModel上创建新公共属性以公开该信息。然后可以将属性绑定到用户界面元素，如文本框。 打开MapViewModel.cs添加以下代码定义一个CurrentExtentString属性。 123456789101112private string extentString;public string CurrentExtentString &#123; get &#123; return this.extentString; &#125; set &#123; this.extentString = value; &#125; &#125; 在MyMapViewExtentChanged中添加以下代码设置CurrentExtentString的值 1234567public void MyMapViewExtentChanged(object parameter)&#123; var mv = parameter as MapView; var extent = mv.Extent; CurrentExtentString = string.Format(&quot;XMin=&#123;0:F2&#125; YMin=&#123;1:F2&#125; XMax=&#123;2:F2&#125; YMax=&#123;3:F2&#125;&quot;, extent.XMin, extent.YMin, extent.XMax, extent.YMax);&#125; 视图范围描述格式如下: 1XMin=-2598746.47 YMin=4253523.55 XMax=5130888.16 YMax=8976345.50. 打开MainWindow.xaml在mapview下添加以下xaml定义一个TextBlock用来显示当前试图范围。 1234&lt;TextBlock Height=&quot;30&quot; Width=&quot;Auto&quot; FontSize=&quot;16&quot; Foreground=&quot;AliceBlue&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Bottom&quot; Text=&quot;&#123;Binding CurrentExtentString&#125;&quot;/&gt; 运行程序，发现范围描述并没有按预期显示出来。 为使数据绑定按预期工作，必须在绑定的属性梗概是触发notification事件。当前情况下在更改视图范围属性前就已经将其绑定到界面文本。当属性值更新时从未通知界面获取更新值，所以界面文本不会改变。 如果是这样的话，为什么绑定的地图工作？ViewModel的incidentmap属性设置在类的构造函数中，设置页面的数据上下文之前就已经赋值。 为了实现属性值改变的通知，我们需要实现System.ComponentModel 命名空间下的 INotifyPropertyChanged 接口。 在MapViewModel中添加以下引用。 12using System.ComponentModel;using System.Runtime.CompilerServices; 在MapViewModel中实现INotifyPropertyChanged接口 123class MapViewModel : INotifyPropertyChanged &#123; ... 添加以下代码实现PropertyChangedEventHandler 12345678public event PropertyChangedEventHandler PropertyChanged;private void RaiseNotifyPropertyChanged([CallerMemberName]string propertyName = null)&#123; if (PropertyChanged != null) &#123; PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); &#125;&#125; 在currentextentstring属性的set访问器中调用RaiseNotifyPropertyChanged函数触发notification。 12345678910111213private string extentString;public string CurrentExtentString &#123; get &#123; return this.extentString; &#125; set &#123; this.extentString = value; this.RaiseNotifyPropertyChanged(); &#125; &#125; 运行程序。当前视图范围显示在地图底部。 至此我们已完成了整个教程。如果你按此教程自己动手实现了。那么你应该对如何创建MVVM模式的ArcgisRuntime应用有了自己的理解。包括：数据绑定、Command、事件触发、属性变更通知。为了体会MVVM模式的有效性。你可以新建一个项目（也可以是其他.net平台），在不同界面下重用本例的ViewModel和Command。 本教程源码：ArcGisRuntime_MVVM_Demo 了解更多要了解更多关于MVVM的知识请参阅以下链接： Data binding overview (MSDN).aspx) MVVM pattern made simple (CodeProject) MVVM Commands (MSDN) INotifyPropertyChanged (.Net Documentation) MVVM Light toolkit (CodePlex) Caliburn.Micro framework (GitHub) 原文地址：https://developers.arcgis.com/net/10-2/desktop/guide/use-the-mvvm-design-pattern.htm","categories":[{"name":"ArcgisRuntime","slug":"ArcgisRuntime","permalink":"http://yxqblog.tk/categories/ArcgisRuntime/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"http://yxqblog.tk/tags/MVVM/"},{"name":"ArcgisRuntime","slug":"ArcgisRuntime","permalink":"http://yxqblog.tk/tags/ArcgisRuntime/"}]},{"title":"ArcMap面要素处理之简化面(Simplify Polygon)","slug":"ArcMap-Ploygon-Simplify","date":"2017-05-14T16:00:00.000Z","updated":"2018-03-25T09:07:17.073Z","comments":true,"path":"2017/05/15/ArcMap-Ploygon-Simplify/","link":"","permalink":"http://yxqblog.tk/2017/05/15/ArcMap-Ploygon-Simplify/","excerpt":"","text":"摘要创建一个新的输出要素类，包含从输入面上删除某些指定大小的部分或孔洞所得的要素。 插图 用法 存在两种简化方法： POINT_REMOVE 方法是两种方法中较快的。它可移除多余的折点。此方法多用于数据压缩或更为粗糙的简化，尤其适用于大家都已经了解的数据。随着容差的增大，生成的面中有棱角的部分（尖锐拐角）将显著增加，所以面要素可能变得不够美观。 BEND_SIMPLIFY 方法较慢，但通常会生成与原始几何形状更为接近的结果，因此更加美观。其操作方式为消除面要素边界上不太重要的弯曲。此方法用于少量的、更为精细的简化。 最小面积参数仅适用于简化的面。任何在简化过程完成后小于最小面积的面要素都将从输出要素类中移除。对于一组共享公共边的相邻面，该参数适用于该组面的总面积。 该工具会产生两个输出要素类，一个是存储了简化之后的面的面要素类和一个是存储了用来表示任意折叠于一点的面的那些点的点要素类。点的输出名称和位置自动从输出的面的名称获得，并以 _Pnt 作为后缀。面输出将包含所有输入字段；点输出不包含任何输入字段。 多部分 (Multipart) 面可简化为单部分。 以下为用于处理输出中的拓扑错误的 3 个选项： NO_CHECK：不检查简化过程所引入的拓扑错误。处理过程会更快。只有在可以保证数据的拓扑准确性时才使用该选项。 FLAG_ERRORS ：将对简化过程所引入的拓扑错误进行标记。当标识拓扑错误的重要性大于解决错误的重要性时，请使用此选项。编辑会话中不支持此选项。 面输出将包含两个表示要素是否存在拓扑错误的新字段。InPoly_FID 和 SimPlyFlag 分别包含输入要素 ID 和拓扑错误。 InPoly_FID 字段将折叠的点连接到其输入面。 在 SimPlyFlag 字段中，值为 1 表示引入了错误，而值为 0（零）表示未引入错误。 拓扑错误解决之后，标记值仍将保持不变。SimPlyFlag 字段用于检查包含拓扑错误的要素。 RESOLVE_ERRORS ：修复简化过程所引入的拓扑错误。处理时间将会更长。编辑会话中不支持此选项。 指定的容差可能会适合大多数面要素，但并非全部，特别是拥挤区域中的面要素。第一轮简化后如果检测到拓扑错误，则将定位涉及的边界线段（非整个面）并使用更小的容差。 此减小后的容差为减小前的百分之五十。新的容差值将用于重新简化这些线段。该迭代过程会根据需要重复多次，直到不存在拓扑错误为止。 面输出要素类包含的面数量与输入要素中包含的面数量相同，并且其使用两个新字段 MaxSimpTol 和 MinSimpTol 存储迭代过程中简化每个面时所应用的最大容差和最小容差。如果未引入错误，MaxSimpTol 和 MinSimpTol 的值将与指定的简化容差的值相同。 如果简化容差值相对较大，较大的面要素旁的较小面要素最终可能会并入较大面要素的内部。本程序无法检测到这种类型的空间关系错误。 对于 NO_CHECK 和 FLAG_ERRORS 选项，简化过程中可能会创建自相交的几何形状，并将自动修复。例如，如果面要素自身存在交叉，则经过修复，它将成为多部分面，以便各部分不存在交叉，尽管面要素的显示效果依然是自交叉。 当使用了 NO_CHECK 或 FLAG_ERRORS 时，或者选中了保留折叠点复选框时，将对点输出进行填充。如果输入面要素包含了多个部分，并且其中一个部分成为折叠的点，则表示该部分的点也将包括在点输出中。 语法1SimplifyPolygon_cartography (in_features, out_feature_class, algorithm, tolerance, &#123;minimum_area&#125;, &#123;error_option&#125;, &#123;collapsed_point_option&#125;) 参数 说明 数据类型 in_features 要简化的面要素。 Feature Layer out_feature_class 要创建的输出面要素类。 Feature Class algorithm 指定面简化算法。POINT_REMOVE —保留构成面的基本几何形状的关键点并移除所有其他点。这是默认设置。BEND_SIMPLIFY —保留面的主要几何形状并移除边界中多余的弯曲。 String tolerance 用于确定简化程度的容差。必须指定一个容差，且值必须大于零。可以选择首选单位；默认为要素单位。对于 POINT_REMOVE 算法，指定的容差表示允许的最大偏移量。对于 BEND_SIMPLIFY 算法，指定的容差表示参考弯曲基线的长度。 Linear unit minimum_area(可选) 设置要保留的简化面的最小面积。默认值为零，即保留所有面。可以为指定的值选择首选单位；默认为要素单位。 Areal unit error_option(可选) 指定处理拓扑错误的方式（这些拓扑错误可能是在处理时引入的，其中包括交叉的线、重叠的线和折叠为零长度的线）。NO_CHECK —指定不检查拓扑错误。这是默认设置。FLAG_ERRORS —指定标记拓扑错误（如果发现拓扑错误）。RESOLVE_ERRORS —指定解决拓扑错误（如果发现拓扑错误）。 String collapsed_point_option(可选) 指定是否将处理中发现的任何折叠的面积为零的面要素作为点保留下来。仅当指定了 NO_CHECK 或 FLAG_ERRORS 时，此选项才可用。KEEP_COLLAPSED_POINTS —指定将折叠的面积为零的面要素作为点保留下来。折叠面中边界的端点将存储在位于输出要素类位置的点要素类中，以输出要素类的名称加上后缀 _Pnt 作为其名称。这是默认设置。NO_KEEP —指定折叠的面积为零的面要素不作为点保留下来，即使在处理中发现也不保留；因此，点要素类将为空。 Boolean 代码实例简化面示例（Python 窗口）以下 Python 窗口脚本演示了如何在即时模式下使用“简化面”工具。 12345import arcpyfrom arcpy import envimport arcpy.cartography as CAenv.workspace = &quot;C:/data&quot;CA.SimplifyPolygon(&quot;soils.shp&quot;, &quot;C:/output/output.gdb/simplified_soils&quot;, &quot;POINT_REMOVE&quot;, 100) 简化面示例 2（独立脚本）以下独立 Python 脚本演示了如何使用“简化面”工具。 123456789101112131415161718192021222324252627# Name: SimplifyPolygon_Example2.py# Description: Eliminate small islands before simplifying and smoothing lake boundaries# Author: ESRI # Import system modulesimport arcpyfrom arcpy import envimport arcpy.management as DMimport arcpy.cartography as CA # Set environment settingsenv.workspace = &quot;C:/data/Portland.gdb/Hydrography&quot; # Set local variablesinLakeFeatures = &quot;lakes&quot;eliminatedFeatures = &quot;C:/data/PortlandOutput.gdb/lakes_eliminated&quot;simplifiedFeatures = &quot;C:/data/PortlandOutput.gdb/lakes_simplified&quot;smoothedFeatures = &quot;C:/data/PortlandOutput.gdb/lakes_smoothed&quot;# Eliminate small islands in lake polygons.DM.EliminatePolygonPart(inLakeFeatures, eliminatedFeatures, 100, &quot;OR&quot;, 0, &quot;CONTAINED_ONLY&quot;) # Simplify lake polygons.CA.SimplifyPolygon(eliminatedFeatures, simplifiedFeatures, &quot;POINT_REMOVE&quot;, 50, 200, &quot;RESOLVE_ERRORS&quot;, &quot;KEEP_COLLAPSED_POINTS&quot;, &quot;CHECK&quot;) # Smooth lake polygons.CA.SmoothPolygon(simplifiedFeatures, smoothedFeatures, &quot;PAEK&quot;, 100, &quot;FLAG_ERRORS&quot;) 了解更多要了解更多关于ArcMap的知识请参阅以下链接： desktop.arcgis.com","categories":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/categories/ArcMap/"}],"tags":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/tags/ArcMap/"},{"name":"Polygon","slug":"Polygon","permalink":"http://yxqblog.tk/tags/Polygon/"},{"name":"Gp","slug":"Gp","permalink":"http://yxqblog.tk/tags/Gp/"}]},{"title":"ArcMap面要素处理之消除面部分(EliminatePolygonPart)","slug":"ArcMap-Ploygon-EliminatePart","date":"2017-04-19T16:00:00.000Z","updated":"2018-03-25T07:16:47.434Z","comments":true,"path":"2017/04/20/ArcMap-Ploygon-EliminatePart/","link":"","permalink":"http://yxqblog.tk/2017/04/20/ArcMap-Ploygon-EliminatePart/","excerpt":"","text":"摘要创建一个新的输出要素类，包含从输入面上删除某些指定大小的部分或孔洞所得的要素。 插图 用法 由于可将面洞看作面的一部分，因此可使用此工具删除或填充面洞。如果洞面积小于指定尺寸，则该洞将被消除，并且在输出中填补该空间。删除的洞中的所有部分也都将在输出中被消除。 部分的大小可以指定为面积、百分比或两者的结合。使用条件参数可确定指定部分大小的方式。条件参数 AREA_AND_PERCENT 和 AREA_OR_PERCENT 选项可使用面积和百分比条件来消除部分。 面部分百分比是以要素总外部面积（包括所有洞的面积）的百分比进行计算的。例如，如果某个具有洞的面的面积为 75 平方米，洞的覆盖面积为 25 平方米，则总的面外部面积为 100 平方米。要消除此洞，需要指定大于 25 平方米的面积，或指定大于 25% 的百分比。如果输入为多部分面，则要素的外部面积为所有面部分所覆盖的面积的总和。 对于多部分面，会将各部分的面积与指定面积进行对比。如果某个面部分小于指定的大小，则该部分将在输出中被消除。 如果面要素的所有部分都小于指定的大小，则会在输出中保留最大的部分，而将其他所有部分消除。 语法1EliminatePolygonPart_management (in_features, out_feature_class, &#123;condition&#125;, &#123;part_area&#125;, &#123;part_area_percent&#125;, &#123;part_option&#125;) 参数 说明 数据类型 in_features 其要素将被复制到输出要素类（消除某些部分或洞）的输入要素类或图层。 Feature Layer out_feature_class 包含其余部分的输出面要素类。 Feature Class condition(可选) 指定要消除的部分的确定方式。AREA —面积小于指定值的部分将被消除。PERCENT —总外部面积百分比小于指定值的部分将被消除。AREA_AND_PERCENT —面积和百分比均小于指定值的部分将被消除。只有同时满足面积和百分比两个条件的面部分才会被删除。AREA_OR_PERCENT —面积或百分比小于指定值的部分将被消除。如果面部分满足面积或百分比条件之一，该面将被删除。 String part_area(可选) 消除小于此面积的部分。 Areal Unit part_area_percent(可选) 消除小于此要素总外部面积百分比的部分。 Double part_option(可选) 确定可消除的部分。CONTAINED_ONLY —仅消除完全包含于其他部分的部分。这是默认设置。ANY —可消除任意部分。 Boolean 代码实例消除面部分示例（Python 窗口）以下 Python 窗口脚本演示了如何在即时模式下使用“消除”工具。 1import arcpy from arcpy import env env.workspace = &quot;C:/data&quot; arcpy.EliminatePolygonPart_management(&quot;buildings.shp&quot;, &quot;output.gdb/remaining_buildings&quot;, &quot;AREA&quot;, 10) 消除面部分示例 2（独立脚本）以下独立 Python 脚本演示了如何使用“消除面部分”工具。 123456789# Name: EliminatePolygonPart_Example2.py # Description: Eliminate small islands before simplifying and smoothing lake boundaries # Author: ESRI # Import system modules import arcpy from arcpy import env # Set environment settings env.workspace = &quot;C:/data/Portland.gdb/Hydrography&quot; # Set local variables inLakeFeatures = &quot;lakes&quot; eliminatedFeatures = &quot;lakes_eliminated&quot; simplifiedFeatures = &quot;lakes_simplified&quot; smoothedFeatures = &quot;lakes_smoothed&quot; # Eliminate small islands in lake polygons. arcpy.EliminatePolygonPart_management(inLakeFeatures, eliminatedFeatures, &quot;AREA&quot;, 100, &quot;&quot;, &quot;CONTAINED_ONLY&quot;) # Simplify lake polygons. arcpy.SimplifyPolygon_cartography(eliminatedFeatures, simplifiedFeatures, &quot;POINT_REMOVE&quot;, 50, 200, &quot;RESOLVE_ERRORS&quot;, &quot;KEEP_COLLAPSED_POINTS&quot;) # Smooth lake polygons. arcpy.SmoothPolygon_cartography(simplifiedFeatures, smoothedFeatures, &quot;BEZIER_INTERPOLATION&quot;) 了解更多要了解更多关于ArcMap的知识请参阅以下链接： desktop.arcgis.com","categories":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/categories/ArcMap/"}],"tags":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/tags/ArcMap/"},{"name":"Polygon","slug":"Polygon","permalink":"http://yxqblog.tk/tags/Polygon/"},{"name":"Gp","slug":"Gp","permalink":"http://yxqblog.tk/tags/Gp/"}]},{"title":"ArcMap面要素处理之消除(Eliminate)","slug":"ArcMap-Ploygon-Eliminate","date":"2017-03-23T16:00:00.000Z","updated":"2018-03-25T07:16:51.850Z","comments":true,"path":"2017/03/24/ArcMap-Ploygon-Eliminate/","link":"","permalink":"http://yxqblog.tk/2017/03/24/ArcMap-Ploygon-Eliminate/","excerpt":"","text":"摘要通过将面与具有最大面积或最长公用边界的邻近面合并来消除面。消除通常用于移除叠加操作（如相交或联合）所生成的小的狭长面。 插图 用法 要消除的要素由应用于面图层的选择内容决定。必须在之前的步骤中使用[按属性选择图层]或[按位置选择图层]或者通过查询 ArcMap 中的地图图层来确定选择内容。 通过删除公用边界来仅将所选面与邻近的未选定面进行合并。所选面将不与邻近的选定面合并。 输入图层必须包含选择内容；否则，消除将失败。 排除表达式和排除图层不会相互排斥，可将二者结合使用以对要消除的要素进行全面控制。 语法1Eliminate_management (in_features, out_feature_class, &#123;selection&#125;, &#123;ex_where_clause&#125;, &#123;ex_features&#125;) 参数 说明 数据类型 in_features 其中的面将与邻近面进行合并的图层。 Feature Layer out_feature_class 待创建的要素类。 Feature Class selection(可选) 这些选项可指定将要使用的消除要素的方法。LENGTH —通过删除公用边界将所选面与邻近的未选定面合并。该邻近面的公用边界最长。这是默认设置。AREA —通过删除公用边界将所选面与邻近的未选定面合并。该邻近面的面积最大。 Boolean ex_where_clause(可选) 用于识别不会被更改的要素的 SQL 表达式。 SQL Expression ex_features(可选) 定义不应被消除的面边界（或部分）的输入折线 (polyline)、面要素类或图层。 Feature Layer 代码实例消除示例（Python 窗口）以下 Python 窗口脚本演示了如何在即时模式下使用“消除”工具。 1234567import arcpyarcpy.env.workspace = &quot;C:/data/Portland.gdb/Census&quot;arcpy.MakeFeatureLayer_management(&quot;blockgrp&quot;, &quot;blocklayer&quot;)arcpy.SelectLayerByAttribute_management(&quot;blocklayer&quot;, &quot;NEW_SELECTION&quot;, &apos;&quot;Area_Sq_Miles&quot; &lt; 0.15&apos;)arcpy.Eliminate_management(&quot;blocklayer&quot;, &quot;C:/output/output.gdb/eliminate_output&quot;, &quot;LENGTH&quot;, &apos;&quot;OBJECTID&quot; = 9&apos;) 消除示例 2（独立脚本）以下独立脚本演示了如何使用“消除”工具。12345678910111213141516171819202122232425# Name: Eliminate_Example2.py# Description: Eliminate features based on a selection. # Import system modulesimport arcpy # Set environment settingsarcpy.env.workspace = &quot;C:/data/Portland.gdb/Census&quot; # Set local variablesinFeatures = &quot;blockgrp&quot;tempLayer = &quot;blocklayer&quot;expression = &apos;&quot;Area_Sq_Miles&quot; &lt; 0.15&apos;outFeatureClass = &quot;C:/output/output.gdb/eliminate_output&quot;exclusionExpression = &apos;&quot;OBJECTID&quot; = 9&apos; # Execute MakeFeatureLayerarcpy.MakeFeatureLayer_management(inFeatures, tempLayer) # Execute SelectLayerByAttribute to define features to be eliminatedarcpy.SelectLayerByAttribute_management(tempLayer, &quot;NEW_SELECTION&quot;, expression) # Execute Eliminatearcpy.Eliminate_management(tempLayer, outFeatureClass, &quot;LENGTH&quot;, exclusionExpression) 了解更多要了解更多关于ArcMap的知识请参阅以下链接： desktop.arcgis.com","categories":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/categories/ArcMap/"}],"tags":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/tags/ArcMap/"},{"name":"Polygon","slug":"Polygon","permalink":"http://yxqblog.tk/tags/Polygon/"},{"name":"Gp","slug":"Gp","permalink":"http://yxqblog.tk/tags/Gp/"}]}]}