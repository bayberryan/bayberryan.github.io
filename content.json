{"meta":{"title":"RickerYan","subtitle":null,"description":null,"author":"RickerYan","url":"http://yxqblog.tk"},"pages":[{"title":"ubuntu18安装和配置caffe+cuda+pycaffe","date":"2018-05-06T16:00:00.000Z","updated":"2018-05-07T10:23:07.004Z","comments":true,"path":"ubuntu18-pycaffe.html","permalink":"http://yxqblog.tk/ubuntu18-pycaffe.html","excerpt":"","text":"Ubuntu InstallationFor Ubuntu (&gt;= 17.04)Installing pre-compiled Caffe Everything including caffe itself is packaged in 17.04 and higher versions. To install pre-compiled Caffe package, just do it by 1sudo apt install caffe-cpu for CPU-only version, or 1sudo apt install caffe-cuda for CUDA version. Note, the cuda version may break if your NVIDIA driver and CUDA toolkit are not installed by APT. Package status of CPU-only version Package status of CUDA version Installing Caffe from source We may install the dependencies by merely one line 12sudo apt build-dep caffe-cpu # dependencies for CPU-only versionsudo apt build-dep caffe-cuda # dependencies for CUDA version It requires a deb-src line in your sources.list. Continue with compilation. For Ubuntu (&lt; 17.04)General dependencies 12sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compilersudo apt-get install --no-install-recommends libboost-all-dev CUDA: Install by apt-get or the NVIDIA .run package. The NVIDIA package tends to follow more recent library and driver versions, but the installation is more manual. If installing from packages, install the library and latest driver separately; the driver bundled with the library is usually out-of-date. This can be skipped for CPU-only installation. BLAS: install ATLAS by sudo apt-get install libatlas-base-dev or install OpenBLAS by sudo apt-get install libopenblas-dev or MKL for better CPU performance. Python (optional): if you use the default Python you will need to sudo apt-get install the python-devpackage to have the Python headers for building the pycaffe interface. Compatibility notes, 16.04 CUDA 8 is required on Ubuntu 16.04. Remaining dependencies, 14.04 Everything is packaged in 14.04. 1sudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev Remaining dependencies, 12.04 These dependencies need manual installation in 12.04. 1234567891011121314151617# glogwget https://github.com/google/glog/archive/v0.3.3.tar.gztar zxvf v0.3.3.tar.gzcd glog-0.3.3./configuremake &amp;&amp; make install# gflagswget https://github.com/schuhschuh/gflags/archive/master.zipunzip master.zipcd gflags-mastermkdir build &amp;&amp; cd buildexport CXXFLAGS=&quot;-fPIC&quot; &amp;&amp; cmake .. &amp;&amp; make VERBOSE=1make &amp;&amp; make install# lmdbgit clone https://github.com/LMDB/lmdbcd lmdb/libraries/liblmdbmake &amp;&amp; make install Note that glog does not compile with the most recent gflags version (2.1), so before that is resolved you will need to build with glog first. Continue with compilation."},{"title":"ubuntu安装和配置caffe+cuda8.0+pycaffe","date":"2018-05-06T16:00:00.000Z","updated":"2018-05-14T06:57:48.665Z","comments":true,"path":"ubuntu-caffe.html","permalink":"http://yxqblog.tk/ubuntu-caffe.html","excerpt":"","text":"1.安装相关依赖项1234sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler sudo apt-get install --no-install-recommends libboost-all-devsudo apt-get install libopenblas-dev liblapack-dev libatlas-base-devsudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev 2.安装NVIDIA驱动（1）查询NVIDIA驱动首先去官网(http://www.nvidia.com/Download/index.aspx?lang=en-us)查看适合自己显卡的驱动： （2）安装驱动 概述 目前，知道3种安装N卡驱动的方法： PPA源：最简便，但未必有最新驱动（亲测），或可能遇到问题（不推荐）。 123sudo add-apt-repository ppa:xorg-edgers/ppa #添加ppa源sudo add-apt-repository ppa:graphics-drivers/ppa #添加ppa源sudo apt-get update #更新apt-get 然后进入：系统设置-&gt;软件和更新-&gt;附件驱动，选择更新的显卡驱动。 安装CUDA时，顺便安装驱动：但未必是最新驱动（亲测）。 去官网下载最新驱动，然后本地安装（本文用runfile）。 卸载原有N卡驱动 123456#for case1: original driver installed by apt-get:sudo apt-get remove --purge nvidia*#for case2: original driver installed by runfile:sudo chmod +x *.runsudo ./NVIDIA-Linux-x86_64-384.59.run --uninstall 如果原驱动是用apt-get安装的，就用第1种方法卸载。 如果原驱动是用runfile安装的，就用–uninstall命令卸载。其实，用runfile安装的时候也会卸载掉之前的驱动，所以不手动卸载亦可。 禁用nouveau驱动 1sudo gedit /etc/modprobe.d/blacklist.conf 在文本最后添加：（禁用nouveau第三方驱动，之后也不需要改回来） 12blacklist nouveauoptions nouveau modeset=0 然后执行：sudo update-initramfs -u 重启后，执行：lsmod | grep nouveau。如果没有屏幕输出，说明禁用nouveau成功。 禁用X-Window服务 1sudo service lightdm stop #这会关闭图形界面，但不用紧张 按Ctrl-Alt+F1进入命令行界面，输入用户名和密码登录即可。 小提示：在命令行输入：sudo service lightdm start ，然后按Ctrl-Alt+F7即可恢复到图形界面。 安装驱动 1234#给驱动run文件赋予执行权限：sudo chmod +x NVIDIA-Linux-x86_64-384.59.run#后面的参数非常重要，不可省略：sudo ./NVIDIA-Linux-x86_64-384.59.run –no-opengl-files –no-opengl-files：表示只安装驱动文件，不安装OpenGL文件。这个参数不可省略，否则会导致登陆界面死循环，英语一般称为”login loop”或者”stuck in login”。 –no-x-check：表示安装驱动时不检查X服务，非必需。 –no-nouveau-check：表示安装驱动时不检查nouveau，非必需。 -Z, --disable-nouveau：禁用nouveau。此参数非必需，因为之前已经手动禁用了nouveau。 -A：查看更多高级选项。 必选参数解释：因为NVIDIA的驱动默认会安装OpenGL，而Ubuntu的内核本身也有OpenGL、且与GUI显示息息相关，一旦NVIDIA的驱动覆写了OpenGL，在GUI需要动态链接OpenGL库的时候就引起问题。 之后，按照提示安装，成功后重启即可。如果提示安装失败，不要急着重启电脑，重复以上步骤，多安装几次即可。 Driver测试： 12nvidia-smi #若列出GPU的信息列表，表示驱动安装成功nvidia-settings #若弹出设置对话框，亦表示驱动安装成功 3.安装CUDACUDA是NVIDIA的编程语言平台，想使用GPU就必须要使用cuda。 （1）下载CUDA首先在官网上(https://developer.nvidia.com/cuda-downloads)下载CUDA： （2）安装CUDA1sudo ./cuda_8.0.61_375.26_linux.run --no-opengl-libs --no-opengl-libs：表示只安装驱动文件，不安装OpenGL文件。必需参数，原因同上。注意：不是-no-opengl-files。 --uninstall (deprecated)：用于卸载CUDA Driver（已废弃）。 --toolkit：表示只安装CUDA Toolkit，不安装Driver和Samples。 --help：查看更多高级选项。 之后，按照提示安装即可。我依次选择了： 123456accept #同意安装n #不安装Driver，因为已安装最新驱动y #安装CUDA Toolkit&lt;Enter&gt; #安装到默认目录y #创建安装目录的软链接n #不复制Samples，因为在安装目录下有/samples 可能出现的错误： 当出现“unsupport complier”错误时，说明gcc版本太高，需要降低gcc版本。解决办法如下： 以gcc4.9与g++4.9为例 安装低版本gcc与g++： 1sudo apt-get install gcc-4.9 g++-4.9 之后进入/usr/bin: 1cd /usr/bin 先删除和gcc5.0关联的gcc: 12sudo rm gccsudo rm g++ 再建个软连接 12sudo ln -s gcc-4.9 gccsudo ln -s g++-4.9 g++ 然后重新安装。 （3）环境变量配置打开~/.bashrc文件： 1sudo vim ~/.bashrc 将以下内容写入到~/.bashrc尾部： 12export PATH=/usr/local/cuda-8.0/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125; （4）测试CUDA的sammples123456789#编译并测试设备 deviceQuery：cd /usr/local/cuda-8.0/samples/1_Utilities/deviceQuerysudo make./deviceQuery#编译并测试带宽 bandwidthTest：cd ../bandwidthTestsudo make./bandwidthTest 如果显示一些关于GPU的信息，则说明安装成功。 4.配置cuDNNcuDNN是GPU加速计算深层神经网络的库。 首先去官网(https://developer.nvidia.com/rdp/cudnn-download)下载cuDNN,可能需要注册一个账号才能下载。 下载cuDNN5.1之后进行解压，cd进入cuDNN5.1解压之后的include目录，在命令行进行如下操作： 1sudo cp cudnn.h /usr/local/cuda/include/ #复制头文件 再将cd进入lib64目录下的动态文件进行复制和链接： 12345sudo cp lib* /usr/local/cuda/lib64/ #复制动态链接库cd /usr/local/cuda/lib64/sudo rm -rf libcudnn.so libcudnn.so.5 #删除原有动态文件sudo ln -s libcudnn.so.5.1.10 libcudnn.so.5 #生成软衔接（注意这里要和自己下载的cudnn版本对应，可以在/usr/local/cuda/lib64下查看自己libcudnn的版本）sudo ln -s libcudnn.so.5 libcudnn.so #生成软链接 5.安装opencv3.1从官网(http://opencv.org/downloads.html)下载Opencv,并将其解压到你要安装的位置，假设解压到了/home/opencv。 安装前准备，创建编译文件夹： 123cd ~/opencvmkdir buildcd build 配置： 1cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. 编译： 1make -j8 #-j8表示并行计算，根据自己电脑的配置进行设置，配置比较低的电脑可以将数字改小或不使用，直接输make。 以上只是将opencv编译成功，还没将opencv安装，需要运行下面指令进行安装： 1sudo make install 可能会出现的错误： 错误内容1： 12gcc-4.9: error trying to exec &apos;cc1plus&apos;: execvp: 没有那个文件或目录 说明gcc与g++版本不兼容，解决办法跟gcc版本太高时一样： 安装低版本gcc与g++： 1sudo apt-get install gcc-4.9 g++-4.9 之后进入/usr/bin: 1cd /usr/bin 先删除和gcc5.0关联的gcc: 12sudo rm gccsudo rm g++ 再建个软连接 12sudo ln -s gcc-4.9 gccsudo ln -s g++-4.9 g++ 错误内容2： 1234modules/cudalegacy/src/graphcuts.cpp:120:54: error: ‘NppiGraphcutState’ has not been declaredtypedef NppStatus (*init_func_t)(NppiSize oSize, NppiGraphcutState** ppState, Npp8u* pDeviceMem); 这是因为opecv3.0与cuda8.0不兼容导致的。解决办法： 修改 ～/opencv/modules/cudalegacy/src/graphcuts.cpp文件内容，如图： 6.配置caffe（1）将终端cd到要安装caffe的位置。 （2）从github上获取caffe： 1git clone https://github.com/BVLC/caffe.git 注意：若没有安装Git，需要先安装Git： 1sudo apt-get install git （3）因为make指令只能make Makefile.config文件，而Makefile.config.example是caffe给出的makefile例子，因此，首先将Makefile.config.example的内容复制到Makefile.config： 1sudo cp Makefile.config.example Makefile.config （4）打开并修改配置文件： 1sudo gedit Makefile.config #打开Makefile.config文件 根据个人情况修改文件： a.若使用cudnn，则 1234将#USE_CUDNN := 1修改成： USE_CUDNN := 1 b.若使用的opencv版本是3的，则 1234将#OPENCV_VERSION := 3 修改为： OPENCV_VERSION := 3 c.若要使用python来编写layer，则 1234将#WITH_PYTHON_LAYER := 1 修改为 WITH_PYTHON_LAYER := 1 d. 重要的一项 : 将# Whatever else you find you need goes here.下面的 12345INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/includeLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib 修改为： INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serialLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu/hdf5/serial 这是因为ubuntu16.04的文件包含位置发生了变化，尤其是需要用到的hdf5的位置，所以需要更改这一路径. （5）修改makefile文件 打开makefile文件，做如下修改： 1234将：NVCCFLAGS +=-ccbin=$(CXX) -Xcompiler-fPIC $(COMMON_FLAGS)替换为：NVCCFLAGS += -D_FORCE_INLINES -ccbin=$(CXX) -Xcompiler -fPIC $(COMMON_FLAGS) （6）编辑/usr/local/cuda/include/host_config.h 将其中的第115行注释掉： 1234将#error-- unsupported GNU version! gcc versions later than 4.9 are not supported!改为//#error-- unsupported GNU version! gcc versions later than 4.9 are not supported! （7）编译 12make all -j8 #-j根据自己电脑配置决定make pycaffe #编译python接口 编译过程中可能会出现如下错误： 错误内容1： 1&quot;fatal error: hdf5.h: 没有那个文件或目录&quot; 解决办法： step1:在Makefile.config文件的第85行，添加/usr/include/hdf5/serial/ 到 INCLUDE_DIRS，也就是把下面第一行代码改为第二行代码。 1234将：INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include替换为：INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serial/ stept2:在Makefile文件的第173行，把 hdf5_hl 和hdf5修改为hdf5_serial_hl 和 hdf5_serial，也就是把下面第一行代码改为第二行代码。 1234将：LIBRARIES += glog gflags protobuf boost_system boost_filesystem m hdf5_hl hdf5改为：LIBRARIES += glog gflags protobuf boost_system boost_filesystem m hdf5_serial_hl hdf5_serial 错误内容2： 1&quot;libcudart.so.8.0 cannot open shared object file: No such file or directory&quot; 解决办法是将一些文件复制到/usr/local/lib文件夹下： 1234#注意自己CUDA的版本号！sudo cp /usr/local/cuda-8.0/lib64/libcudart.so.8.0 /usr/local/lib/libcudart.so.8.0 &amp;&amp; sudo ldconfigsudo cp /usr/local/cuda-8.0/lib64/libcublas.so.8.0 /usr/local/lib/libcublas.so.8.0 &amp;&amp; sudo ldconfigsudo cp /usr/local/cuda-8.0/lib64/libcurand.so.8.0 /usr/local/lib/libcurand.so.8.0 &amp;&amp; sudo ldconfig （8）测试 1sudo make runtest 测试通过，说明caffe配置成功。 到此caffe配置完毕！ MNIST数据集测试配置caffe完成后，我们可以利用MNIST数据集对caffe进行测试，过程如下： 1.将终端定位到Caffe根目录 1cd ~/caffe 2.下载MNIST数据库并解压缩 1./data/mnist/get_mnist.sh 3.将其转换成Lmdb数据库格式 1./examples/mnist/create_mnist.sh 4.训练网络 1./examples/mnist/train_lenet.sh 训练的时候可以看到损失与精度数值。"},{"title":"video","date":"2018-04-11T04:51:38.000Z","updated":"2018-04-11T06:04:26.308Z","comments":true,"path":"video/index.html","permalink":"http://yxqblog.tk/video/index.html","excerpt":"","text":"$(document).ready(function(){ $(\"#play\").click(function(){ var url = $(\" #url \").val(); var server=\"http://api.baiyug.cn/vip/index.php?url=\"; $('#frame').attr(\"src\",server+url); }); }); function changeFrameHeight(){ var ifm= document.getElementById(\"frame\"); ifm.height=document.documentElement.clientHeight-300; } window.onresize=function(){ changeFrameHeight(); } 主流平台Vip视频播放! 播放"},{"title":"about","date":"2017-03-25T05:25:52.000Z","updated":"2018-04-05T08:40:29.237Z","comments":true,"path":"about/index.html","permalink":"http://yxqblog.tk/about/index.html","excerpt":"","text":"关于本站本站采用hexo搭建，托管于github。缘起： 相信每个有想法的码农都希望有一个自己的网站。 搬砖搬多了，人越来越木讷、话不会说、文章不会写。希望通过博客写写字锻炼锻炼。 记录生活和技术上踩过的坑及自己的感悟，自省，分享。 关于我多年从事GIS、RS、GNSS桌面端和服务端开发，主要开发语言C# 、IDL、C++。入坑较早，辗转接触使用过Fortran、C等古老语种，使用过JavaScript、Python等脚本语言。考虑过转投JAVA阵营，无奈接触项目多为桌面系统。最终还是留在了微软系继续深耕。多年踩坑，从数据库到服务端到桌面端和web前端有了自己的理解。主要技术栈： 数据库：Oracle、Postgresql、Postgis、SQLite 服务端：Asp.Net、Asp.Net MVC、Asp.Net WebApi 桌面端：WinForm、WPF、QT 前端：Leaflet、Openlayer 关于工作 第一份工作，坐标海口大三花了半年的时间在国家航测局第四航测遥感院实习。彼时对自己专业没什么了解，总想知道自己花四年时间学的专业到底能干什么。半年实习结束，本就对专业无兴趣的我，更坚定了信念。 第二份工作，坐标济南大四不知为什么，稀里糊涂就去了国土测绘院。主要工作与大三实习大同小异。最后过了实习期，决定转行，去做了两个月通信线路设计。无奈身体实在吃不消，最后回到青岛开始了码农生涯。 第三份工作，坐标青岛开始了全职码农生涯。从桌面，到web到数据库有什么项目就做什么事。 如今，坐标帝都算是初创公司，在做自己的产品。既与自己专业相关，又与自己兴趣相宜。很是幸运。 关于爱好第一爱好搬砖（认真起来一天茶饭不思）、第二唱歌（可通宵唱不停）、第三独处发呆（不说一句话） 联系我 Blog: yxqblog.tk Email: bayberryan@hotmail.com Github: bayberryan Linkedin: bayberryan"}],"posts":[{"title":"项目网络图","slug":"network-diagram","date":"2018-04-10T16:00:00.000Z","updated":"2018-05-17T10:17:38.495Z","comments":true,"path":"2018/04/11/network-diagram/","link":"","permalink":"http://yxqblog.tk/2018/04/11/network-diagram/","excerpt":"","text":"项目网络图项目网络图指由箭线和节点组成的，用来表示工作流程的有向、有序网状图形是工程管理和项目管理中对工作范围和进度管理的常用工具。常用的有双代号网络图和单代号网络图两种。 双代号网络图双代号网络图（activity-on-arrow network diagram，简称AOA）是以箭线或其两端节点的编号表示工作的网络图。如下图所示，某项工作由一根箭线和两个圆圈表示，一般工作名称（图中A、B、C…）写在箭线上面，完成工作所需的时间（图中t=4 mo、t=3 mo…）写在箭线下面，箭尾表示工作开始，箭头表示工作结束。圆圈中的两个号码来代表这项工作。 单代号网络图单代号网络图（activity-on-note network diagram，简称AON）也称紧前关系绘图法(precedence diagramming method，简称PDM)，以节点或该节点编号表示工作的网络图。如下图所示，单代号网络图中的节点一般用圆圈或方框来绘制，代表一项工作，在圆圈或方框内可以写上工作的编号、名称和需要的作业时间；箭线表示紧邻工作之间的逻辑关系，不占用时间和消耗资源，箭线水平投影的方向应自左向右，表示工作的行进方向。","categories":[{"name":"项目管理","slug":"项目管理","permalink":"http://yxqblog.tk/categories/项目管理/"}],"tags":[{"name":"项目管理","slug":"项目管理","permalink":"http://yxqblog.tk/tags/项目管理/"},{"name":"网络图","slug":"网络图","permalink":"http://yxqblog.tk/tags/网络图/"}]},{"title":"主流平台视频解析播放","slug":"Video-Vip","date":"2018-04-10T16:00:00.000Z","updated":"2018-04-11T13:31:05.580Z","comments":true,"path":"2018/04/11/Video-Vip/","link":"","permalink":"http://yxqblog.tk/2018/04/11/Video-Vip/","excerpt":"","text":"博客新增主流平台视频视频解析播放入口。 使用方法 进入博客主页、点击导航栏的Video标签进入解析界面。 复制要观看的视频页面链接粘贴到博客界面的输入框，点击播放开始观看视频。如下图： tips：博客页面加载时默认播放，可点击左下角停止播放 视频解析接口视频解析接口由 百域阁 提供，支持的视频平台如下图示：","categories":[{"name":"视频","slug":"视频","permalink":"http://yxqblog.tk/categories/视频/"}],"tags":[{"name":"Vip视频","slug":"Vip视频","permalink":"http://yxqblog.tk/tags/Vip视频/"}]},{"title":"国标-计算机软件产品开发文件编制指南 GB 8567-88","slug":"GB-Soft-Doc","date":"2018-04-04T16:00:00.000Z","updated":"2018-04-05T13:33:32.649Z","comments":true,"path":"2018/04/05/GB-Soft-Doc/","link":"","permalink":"http://yxqblog.tk/2018/04/05/GB-Soft-Doc/","excerpt":"","text":"目的一项计算机软件的筹划、研制及实现，构成一个软件开发项目。一个软件开发项目的进行，一般需要在人力和自动化资源等方面作重大的投资。为了保证项目开发的成功，最经济地花费这些投资，并且便于运行和维护，在开发工作的每一阶段，都需要编制一定的文件。这些文件连同计算机程序及数据一起，构成为计算机软件。文件是计算机软件中不可缺少的组成部分，它的作用是： 作为开发人员在一定阶段内的工作成果和结束标志； 向管理人员提供软件开发过程中的进展和情况，把软件开发过程中的一些“不可见的”事物转 换成“可见的”文字资料。以便管理人员在各个阶段检查开发计划的实施进展，使之能够判断原定目标是否已达到，还将继续耗用资源的种类和数量； 记录开发过程中的技术信息，便于协调以后的软件开发、使用和修改； 提供对软件的有关运行、维护和培训的信息，便于管理人员、开发人员、操作人员和用户之间相互了解彼此的工作； 向潜在用户报导软件的功能和性能，使他们能判定该软件能否服务于自己的需要。换言之，本指南认为：文件的编制必须适应计算机软件整个生存周期的需要。计算机软件所包含的文件有两类：一类是开发过程中填写的各种图表，可称之为工作表格；另一类则是应编制的技术资料或技术管理资料，可称之为文件。本指南规定软件文件的编制形式，并提供对这些规定的解释。本指南的目的是使得所编制的软件文件确实能够起到软件文件应该发挥的作用。 范围本指南是一份指导性文件。本指南建议，在一项计算机软件的开发过程中，一般地说，应该产生十四种文件。这十四种文件是： 可行性研究报告； 项目开发计划； 软件需求说明书； 数据要求说明书； 概要设计说明书； 详设计说明书； 数据库设计说明书； 用户手册； 操作手册； 模块开发卷宗； 测试计划； 测试分析报告； 开发进度月报； 项目开发总结报告。 本指南将给出开发过程中建议产生的这十四种文件的编制指导，同时，本指南也是这十四种文件的编写质量的检验准则。但是，本指南并未涉及软件开发过程中如何填写工作表格的问题。 一般地说，一个软件总是一个计算机系统（包括硬件、固件和软件）的组成部分。鉴于计算机系统的多样性，本指南一般不涉及整个系统开发中的文件编制问题，本指南仅仅是软件开发过程中的文件编制指南。 文件的使用者对于使用文件的人员而言，他们所关心的文件的种类，随他们所承担的工作而异。 管理人员： 可行性研究报告 项目开发计划 模块开发卷宗 开发进度月报 项目开发总结报告 开发人员： 可行性研究报告 项目开发计划 软件需求说明书 数据要求说明书 概要设计说明书 详细设计说明书 数据库设计说明书 测试计划 测试分析报告 维护人员： 设计说明书 测试分析报告 模块开发卷宗 用户： 用户手册 操作手册 尽管本指南提出了在软件开发中文件编制的要求，但并不意味着这些文件都必须交给用户。一项软件的用户应该得到的文件的种类由供应者与用户之间签订的合同规定。 软件生存周期与各种文件的编制一项计算机软件，从出现一个构思之日起，经过这项软件开发成功投入使用，直到最后决定停止使用，并被另一项软件代替之时止，被认为是该软件的一个生存周期。一般地说这个软件生存周期可以分成以下六个阶段： 可行性与计划研究阶段 需求分析阶段 设计阶段 实现阶段 测试阶段 运行与维护阶段 在可行性研究与计划阶段内，要确定该软件的开发目标和总的要求，要进行可行性分析、投资一收益分析、制订开发计划，并完成应编制的文件。 在需求分析阶段内，由系统分析人员对被设计的系统进行系统分析，确定对该软件的各项功能、性能需求和设计约束，确定对文件编制的要求，作为本阶段工作的结果，一般地说，软件需求说明书、数据要求说明书和初步的用户手册应该编写出来。 在设计阶段内，系统设计人员和程序设计人员应该在反复理解软件需求的基础上，提出多个设计，分析每个设计能履行的功能并进行相互比较，最后确定一个设计，包括该软件的结构、模块的划分、功能的分配以及处理流程。在被设计系统比较复杂的情况下，设计阶段应分解成概要设计阶段和详细设计阶段两个步骤。在一般情况下，应完成的文件包括：概要设计说明书、详细设计说明书和测试计划初稿。 在实现阶段内，要完成源程序的编码、编译（或汇编）和排错调试得到无语法错的程序清单，要开始编写模块开发卷宗，并且要完成用户手册、操作手册等面向用户的文件的编写工作，还要完成测试计划的编制。 在测试阶段，该程序将被全面地测试，已编制的文件将被检查审阅。一般要完成模块开发卷宗和测试分析报告，作为开发工作的结束，所生产的程序、文件以及开发工作本身将逐项被评价，最后写出项目开发总结报告。 在整个开发过程中（即前五个阶段中），开发集体要按月编写开发进度月报。 在运行和维护阶段，软件将在运行使用中不断地被维护，根据新提出的需求进行必要而且可能的扩充和删改。 对于一项软件而言，其生存周期各阶段与各种文件编写工作的关系可见表互，其中有些文件的编写工作可能要在若干个阶段中延续进行。 表1软件生存周期各阶段中的文件编制 文件编制的管理工作文件编制工作必须有管理工作的配合，才能使所编制的文件真正发挥它的作用。文件的编制工作实际上贯穿于一项软件的整个开发过程，因此，对文件的管理必须贯穿于整个开发过程。在开发过程中必须进行的管理工作是以下四条。 文件的形成开发集体中的每个成员，尤其是项目负责人，应该认识到：文件是软件产品的必不可少的组成部分；在软件开发过程的各个阶段中，必须按照规定及时地完成各种产品文件的编写工作；必须把在一个开发步骤中作出的决定和取得的结果及时地写入文件；开发集体必须及时地对这些文件进行严格的评审；这些文件的形成是各个阶段开发工作正式完成的标志。这些文件上必须有编写者、评审者和批准者的签字，必须有编写、评审完成的日期和批准的日期。 文件的分类与标识在软件开发的过程中，产生的文件是很多的，为了便于保存、查找、使用和修改，应该对文件按层次地加以分类组织。一个软件开发单位应该建立一个对本单位文件的标识方法，使文件的每一页都具有明确的标识。例如可以按如下四个层次对文件加以分类和标识。a) 文件所属的项目的标识；b) 文件种类的标识；c) 同一种文件的不同版本号；d) 页号。此外，对每种文件还应根据项目的性质，划定它们各自的保密级别，确定他们各自的发行范围。 文件的控制在一项软件的开发过程中，随着程序的逐步形成和逐步修改，各种文件亦在不断地产生、不断地修改或补充。因此，必须加以周密的控制，以保持文件与程序产品的一致性，保持各种文件之间的一致性和文件的安全性。这种控制表现为：a．就从事一项软件开发工作的开发集体而言，应设置一位专职的文件管理人员（接口管理工程师或文件管理员）；在开发集体中，应该集中保管本项目现有全部文件的主文本两套，由该文件管理人员负责保管；b．每一份提交给文件管理人员的文件都必须具有编写人、审核人和批准人的签字；C．这两套主文本的内容必须完全一致；其中有一套是可供出借的，另一套是绝对不能出借的，以免发生万一；可出借的主文本在出借时必须办理出借手续，归还时办理注销出借手续；d．开发集体中的工作人员可以根据工作的需要，在本项目的开发过程中持有一些文件，即所谓个人文件，包括为使他完成他承担的任务所需要的文件，以及他在完成任务过程中所编制的文件；但这种个人文件必须是主文本的复制品，必须同主文本完全一致，若要修改，必须首先修改主文本；e．不同开发人员所拥有的个人文件通常是主文本的各种子集；所谓子集是指把主文本的各个部分根据承担不同任务的人员或部门的工作需要加以复制、组装而成的若干个文件的集合；文件管理人员。应该列出一份不同子集的分发对象的清单，按照清单及时把文件分发给有关人员或部门；f．一份文件如果已经被另一份新的文件所代替，则原文件应该被注销；文件管理人中要随时整理主文本，及时反映出文件的变化和增加情况，及时分发文件；g．当一个项目的开发工作临近结束时，文件管理人员应逐个收回开发集体内每个成员的个人文件，并检查这些个人文件的内容；经验表明，这些个人文件往往可能比主文本更详细，或同主文本的内容有所不同，必须认真监督有关人员进行修改，使主文本能真正反映实际的开发结果。 文件的修改管理在一个项目的开发过程中的任何时刻，开发集体内的所有成员都可能对开发工作的已有成果—— 文件，提出进行修改的要求。提出修改要求的理由可能是各种各样的，进行修改而引起的影响可能很小，也可能会牵涉到本项目的很多方面。因此，修改活动的进行必须谨慎，必须对修改活动的进行加以管理， 必须执行修改活动的规程，使整个修改活动有控制地进行。 修改活动可分如下五个步骤进行： a．提议开发集体中的任何一个成员都可以向项目负责人提出修改建议，为此应该填写一份修改建议表，说明修改的内容、所修改的文件和部位、以及修改理由；b．评议由项目负责人或项目负责人指定的人员对该修改建议进行评议，包括审查该项修改的必要性、确定这一修改的影响范围、研究进行修改的方法、步骤和实施计划；c．审核一般由项目负责人进行审核，包括核实修改的自的和要求、核实修改活动将带来的影响、审核修改活动计划是否可行；d．批准在一般情况下，批准权属于该开发单位的部门负责人；在批准时，主要是决断修改工作中各项活动的先后顺序及各自的完成日期，以保证整个开发工作按原定计划日期完成；e．实施由项目负责人按照已批准的修改活动计划，安排各项修改活动的负责人员进行修改，建立修改记录、产生新的文件以取代原有文件、最后把文件交文件管理人员归档，并分发给有关的持有者。 可行性研究报告可行性研究报告的编写目的是：说明该软件开发项目的实现在技术、经济和社会条件方面的可行 性；评述为了合理地达到开发目标而可能选择的各种方案；说明并论证所选定的方案。 可行性研究报告的编写内容要求如下： 1引言1.1编写目的 说明编写本可行性研究报告的目的，指出预期的读者。 1.2背景 说明：a．所建议开发的软件系统的名称；b．本项目的任务提出者、开发者、用户及实现该软件的计算中心或计算机网络；c．该软件系统同其他系统或其他机构的基本的相互来往关系。 1.3定义 列出本文件中用到的专门术语的定义和外文首字母组词的原词组。 1.4参考资料 列出用得着的参考资料，如：a． 本项目的经核准的计划任务书或合同、上级机关的批文；b． 属于本项目的其他已发表的文件；c． 本文件中各处引用的文件、资料，包括所需用到的软件开发标准。|列出这些文件资料的标题、文件编号、发表日期和出版单位，说明能够得到这些文件资料的来源。 2可行性研究的前提 说明对所建议的开发项目进行可行性研究的前提，如要求、目标、假定、限制等。 2.1要求 说明对所建议开发的软件的基本要求，如：a． 功能；b． 性能；c． 输出如报告、文件或数据，对每项输出要说明其特征，如用途、产生频度、接口以及分发对象；d． 输入说明系统的输入，包括数据的来源、类型、数量、数据的组织以及提供的频度；e． 处理流程和数据流程用图表的方式表示出最基本的数据流程和处理流程，并辅之以叙述；f． 在安全与保密方面的要求；g． 同本系统相连接的其他系统；h． 完成期限。 2.2目标 说明所建议系统的主要开发目标，如：a. 人力与设备费用的减少；b. 处理速度的提高；c. 控制精度或生产能力的提高；d. 管理信息服务的改进；e. 自动决策系统的改进；f. 人员利用率的改进。 2.3条件、假定和限制 说明对这项开发中给出的条件、假定和所受到的限制，如：a． 所建议系统的运行寿命的最小值；b． 进行系统方案选择比较的时间；c． 经费、投资方面的来源和限制；d． 法律和政策方面的限制；e． 硬件、软件、运行环境和开发环境方面的条件和限制；f． 可利用的信息和资源；g． 系统投入使用的最晚时间。 2.4进行可行性研究的方法 说明这项可行性研究将是如何进行的，所建议的系统将是如何评价的。摘要说明所使用的基本方法 和策略，如调查、加权、确定模型、建立基准点或仿真等。 2.5评价尺度 说明对系统进行评价时所使用的主要尺度，如费用的多少、各项功能的优先次序、开发时间的长短 及使用中的难易程度。 3对现有系统的分析 这里的现有系统是指当前实际使用的系统，这个系统可能是计算机系统，也可能是一个机械系统甚 至是一个人工系统。分析现有系统的目的是为了进一步阐明建议中的开发新系统或修改现有系统的必要性。 3.1数据流程和处理流程 说明现有系统的基本的处理流程和数据流程。此流程可用图表即流程图的形式表示，并加以叙述。 3.2工作负荷 列出现有系统所承担的工作及工作量。 3.3费用开支 列出由于运行现有系统所引起的费用开支，如人力、设备、空间、支持性服务、材料等项开支以及开 支总额。 3.4人员 列出为了现有系统的运行和维护所需要的人员的专业技术类别和数量。 3.5设备 列出现有系统所使用的各种设备。 3.6局限性 列出本系统的主要的局限性，例如处理时间赶不上需要，响应不及时，数据存储能力不足，处理功能 不够等。并且要说明，为什么对现有系统的改进性维护已经不能解决问题。 4所建议的系统 本章将用来说明所建议系统的目标和要求将如何被满足。 4.1对所建议系统的说明 概括地说明所建议系统，并说明在第A．2章中列出的那些要求将如何得到满足，说明所使用的基本 方法及理论根据。 4.2数据流程和处理流程 给出所建议系统的处理流程和数据流程。 4.3改进之处 按2．2条中列出的目标，逐项说明所建议系统相对于现存系统具有的改进。 4.4影响 说明在建立所建议系统时，预期将带来的影响，包括： 4.4.1对设备的影响 说明新提出的设备要求及对现存系统中尚可使用的设备须作出的修改。 4.4.2对软件的影响 说明为了使现存的应用软件和支持软件能够同所建议系统相适应。而需要对这些软件所进行的修 改和补充。 4.4.3对用户单位机构的影响 说明为了建立和运行所建议系统，对用户单位机构、人员的数量和技术水平等方面的全部要求。 4.4.4对系统运行的影响 说明所建议系统对运行过程的影响，如：a． 用户的操作规程；b． 运行中心的操作规程；c． 运行中心与用户之间的关系；d． 源数据的处理；e． 数据进入系统的过程；f． 对数据保存的要求，对数据存储、恢复的处理；g． 输出报告的处理过程、存储媒体和调度方法；h． 系统失效的后果及恢复的处理办法。 4.4.5对开发的影响 说明对开发的影响，如：a. 为了支持所建议系统的开发，用户需进行的工作；b. 为了建立一个数据库所要求的数据资源；c. 为了开发和测验所建议系统而需要的计算机资源；d. 所涉及的保密与安全问题。 4.4.6对地点和设施的影响 说明对建筑物改造的要求及对环境设施的要求。 4.4.6对经费开支的影响 扼要说明为了所建议系统的开发，设计和维持运行而需要的各项经费开支。 4.5局限性 说明所建议系统尚存在的局限性以·及这些问题未能消除的原因。 4.6技术条件方面的可行性 本节应说明技术条件方面的可行性，如：a． 在当前的限制条件下，该系统的功能目标能否达到；b． 利用现有的技术，该系统的功能能否实现；c． 对开发人员的数量和质量的要求并说明这些要求能否满足；d． 在规定的期限内，本系统的开发能否完成。 5可选择的其他系统方案 扼要说明曾考虑过的每一种可选择的系统方案，包括需开发的和可从国内国外直接购买的，如果没 有供选择的系统方案可考虑，则说明这一点。 5.1可选择的系统方案1 参照第4章的提纲，说明可选择的系统方案1，并说明它未被选中的理由。 5.2可选择的系统方案2 按类似 5.1条的方式说明第2个乃至第n个可选择的系统方案。 ……6投资及收益分析6.1支出 对于所选择的方案，说明所需的费用。如果已有一个现存系统，则包括该系统继续运行期间所需的费用。 6.1.1基本建设投资 包括采购、开发和安装下列各项所需的费用，如：a． 房屋和设施；b． A DP设备；c． 数据通讯设备；d． 环境保护设备；e． 安全与保密设备；f． ADP操作系统的和应用的软件；g． 数据库管理软件。 6.1.2其他一次性支出 包括下列各项所需的费用，如：a． 研究（需求的研究和设计的研究）；b． 开发计划与测量基准的研究；c． 数据库的建立；d． ADP软件的转换；e． 检查费用和技术管理性费用；f． 培训费、旅差费以及开发安装人员所需要的一次性支出；g． 人员的退休及调动费用等。 6.1.3非一次性支出 列出在该系统生命期内按月或按季或按年支出的用于运行和维护的费用，包括：a． 设备的租金和维护费用；b． 软件的租金和维护费用；c． 数据通讯方面的租金和维护费用；d． 人员的工资、奖金；e． 房屋、空间的使用开支；f． 公用设施方面的开支；g． 保密安全方面的开支；h． 其他经常性的支出等。 6.2收益 对于所选择的方案，说明能够带来的收益，这里所说的收益，表现为开支费用的减少或避免、差错的减少、灵活性的增加、动作速度的提高和管理计划方面的改进等，包括； 6.2.1一次性收益 说明能够用人民币数目表示的一次性收益，可按数据处理、用户、管理和支持等项分类叙述，如：a. 开支的缩减包括改进了的系统的运行所引起的开支缩减，如资源要求的减少，运行效率的改进，数据进入、存贮和恢复技术的改进，系统性能的可监控，软件的转换和优化，数据压缩技术的采用，处理的集中化／分布化等；b. 价值的增升包括由于一个应用系统的使用价值的增升所引起的收益，如资源利用的改进，管理和运行效率的改进以及出错率的减少等；c. 其他如从多余设备出售回收的收入等。 6.2.2非一次性收益 说明在整个系统生命期内由于运行所建议系统而导致的按月的、按年的能用人民币数目表示的收益，包括开支的减少和避免。 6.2.3不可定量的收益 逐项列出无法直接用人民币表示的收益，如服务的改进，由操作失误引起的风险的减少，信息掌握情况的改进，组织机构给外界形象的改善等。有些不可捉摸的收益只能大概估计或进行极值估计（按最好和最差情况估计）。 6.3收益／投资比 求出整个系统生命期的收益／投资比值。 6.4投资回收周期 求出收益的累计数开始超过支出的累计数的时间。 6.5敏感性分析 所谓敏感性分析是指一些关键性因素如系统生命期长度、系统的工作负荷量、工作负荷的类型与这些不同类型之间的合理搭配、处理速度要求、设备和软件的配置等变化时，对开支和收益的影响最灵敏的范围的估计。在敏感性分析的基础上做出的选择当然会比单一选择的结果要好一些。 7社会条件方面的可行性 本章用来说明对社会因素方面的可行性分析的结果，包括： 7.1法律方面的可行性 法律方面的可行性问题很多，如合同责任、侵犯专利权、侵犯版权等方面的陷井，软件人员通常是不熟悉的，有可能陷入，务必要注意研究。 7.2使用方面的可行性 例如从用户单位的行政管理、工作制度等方面来看，是否能够使用该软件系统；从用户单位的工作人员的素质来看，是否能满足使用该软件系统的要求等等，都是要考虑的。 8结论 在进行可行性研究报告的编制时，必须有一个研究的结论。结论可以是：a. 可以立即开始进行；b. 需要推迟到某些条件（例如资金、人力、设备等）落实之后才能开始进行；c. 需要对开发目标进行某些修改之后才能开始进行；d. 不能进行或不必进行（例如因技术不成熟、经济上不合算等）。 项目开发计划编制项目开发计划的目的是用文件的形式，把对于在开发过程中各项工作的负责人员、开发进度、 所需经费预算、所需软、硬件条件等问题作出的安排记载下来，以便根据本计划开展和检查本项目的开 发工作。编制内容要求如下： 1引言1.1编写目的 说明编写这份项目开发计划的目的，并指出预期的读者。 1.2背景 说明：a． 待开发的软件系统的名称；b． 本项目的任务提出者、开发者、用户及实现该软件的计算中心或计算机网络；c． 该软件系统同其他系统或其他机构的基本的相互来往关系。 1.3定义 列出本文件中用到的专门术语的定义和外文首字母组词的原词组。 1.4参考资料 列出用得着的参考资料，如：a． 本项目的经核准的计划任务书或合同、上级机关的批文；b． 属于本项目的其他已发表的文件；c． 本文件中各处引用的文件、资料，包括所要用到的软件开发标准。 列出这些文件资料的标题、文件编号、发表日期和出版单位，说明能够得到这些文件资料的来源。 2项目概述2.11作内容 简要地说明在本项目的开发中须进行的各项主要工作。 2.2主要参加人员 扼要说明参加本项目开发工作的主要人员的情况，包括他们的技术水平。 2.3产品及成果2.3.1程序 列出需移交给用户的程序的名称、所用的编程语言及存储程序的媒体形式，并通过引用有关文件， 逐项说明其功能和能力。 2.3.2文件 列出需移交给用户的每种文件的名称及内容要点。 2.3.3服务 列出需向用户提供的各项服务，如培训安装、维护和运行支持等，应逐项规定开始日期、所提供支持 的级别和服务的期限。 2.3.4非移交产品 说明开发集体应向本单位交出但不必向用户移交的产品（文件甚至某些程序）。 2.4验收标准 对于上述这些应交出的产品和服务，逐项说明或引用资料说明验收标准。 2.5完成项目的最迟期限2·6本计划的审查者与批准者3实施总计划3.1工作任务的分解 对于项目开发中需完成的各项工作，从需求分析、设计、实现、测试直到维护，包括文件的编制、审批、打印、分发工作，用户培训工作，软件安装工作等，按层次进行分解，指明每项任务的负责人和参加人员。 3.2接口人员 说明负责接口工作的人员及他们的职责，包括：a. 负责本项目同用户的接口人员；b. 负责本项目同本单位各管理机构，如合同计划管理部门、财务部门、质量管理部门等的接口人员；c. 负责本项目同各分合同负责单位的接口人员等。 3.3进度 对于需求分析、设计、编码实现、测试、移交、培训和安装等工作，给出每项工作任务的预。定开始日期、完成日期及所需资源，规定各项工作任务完成的先后顺序以及表征每项工作任务完成的标志性事件（即所谓“里程碑”）。 3.4预算 逐项列出本开发项目所需要的劳务（包括人员的数量和时间）以及经费的预算（包括办公费、差旅费、机时费、资料费、通讯设备和专用设备的租金等）和来源。 3.5关键问题 逐项列出能够影响整个项目成败的关键问题、技术难点和风险，指出这些问题对项目的影响。 4支持条件 说明为支持本项目的开发所需要的各种条件和设施。 4.1计算机系统支持 逐项列出开发中和运行时所需的计算机系统支持，包括计算机、外围设备、通讯设备、模拟器、编译 （或 汇编）程序、操作系统、数据管理程序包、数据存储能力和测试支持能力等，逐项给出有关到货日期、 使用时间的要求。 4·2需要用户承担的工作 逐项列出需要用户承担的工作和完成期限。包括需由用户提供的条件及提供时间。 4·3需由外单位提供的条件 逐项列出需要外单位分合同承包者承担的工作和完成的时间，包括需要由外单位提供的条件和提 供的时间。 5专题计划要点 说明本项目开发中需制订的各个专题计划（如分合同计划、开发人员培训计划、测试计划、安全保密 计划、质量保证计划、配置管理计划、用户培训计划、系统安装计划等）的要点。 软件需求说明书软件需求说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解， 使之成为整个开发工作的基础。编制软件需求说明书的内容要求如下： 1引言1.1编写目的 说明编写这份软件需求说明书的目的，指出预期的读者。 1.2背景 说明：a． 待开发的软件系统的名称；b． 本项目的任务提出者、开发者、用户及实现该软件的计算中心或计算机网络；c． 该软件系统同其他系统或其他机构的基本的相互来往关系。 1.3定义 列出本文件中用到的专门术语的定义和外文首字母组词的原词组。 1.4参考资料 列出用得着的参考资料，如： a．本项目的经核准的计划任务书或合同、上级机关的批文； b．属于本项目的其他已发表的文件； c．本文件中各处引用的文件、资料、包括所要用到的软件开发标准。 列出这些文件资料的标题、文件编号、发表日期和出版单位，说明能够得到这些文件资料的来源。 2任务概述2.1目标 叙述该项软件开发的意图、应用目标、作用范围以及其他应向读者说明的有关该软件开发的背景材料。解释被开发软件与其他有关软件之间的关系。如果本软件产品是一项独立的软件，而且全部内容自含，则说明这一点。如果所定义的产品是一个更大的系统的一个组成部分，则应说明本产品与该系统中其他各组成部分之间的关系，为此可使用一张方框图来说明该系统的组成和本产品同其他各部分的联系和接口。 2.2、用户的特点 列出本软件的最终用户的特点，充分说明操作人员、维护人员的教育水平和技术专长，以及本软件的预期使甩频度。这些是软件设计工作的重要约束 2.3假定与约束 列出进行本软件开发工作的假定和约束，例如经费限制、开发期限等。 3需求规定3.1对功能的规定 用列表的方式（例如IPO表即输入、处理、输出表的形式），逐项定量和定性地叙述对软件所提出的功能要求，说明输入什么量、经怎样的处理、得到什么输出，说明软件应支持的终端数和应支持的并行操作的用户数。 3.2对性能的规定3.2.1精度 说明对该软件的输入、输出数据精度的要求，可能包括传输过程中的精度。 3.2.2时间特性耍求 说明对于该软件的时间特性要求，如对： a．响应时间； b．更新处理时间； c．数据的转换和传送时间； d·解题时间； 等的要求。 3.2.3灵活性 说明对该软件的灵活性的要求，即当需求发生某些变化时，该软件对这些变化的适应能力，如： a. 操作方式上的变化； b· 运行环境的变化； c．同其他软件的接口的变化； d．精度和有效时限的变化； e. 计划的变化或改进。 对于为了提供这些灵活性而进行的专门设计的部分应该加以标明。 3.3输入输出要求 解释各输入输出数据类型，并逐项说明其媒体、格式、数值范围、精度等。对软件的数据输出及必须标明的控制输出量进行解释并举例，包括对硬拷贝报告（正常结果输出、状态输出及异常输出）以及图形或显示报告的描述。 3.4数据管理能力要求 说明需要管理的文卷和记录的个数、表和文卷的大小规模，要按可预见的增长对数据及其分量的存储要求作出估算。 3.5故障处理要求 列出可能的软件、硬件故障以及对各项性能而言所产生的后果和对故障处理的要求。 3.6其他专门要求 如用户单位对安全保密的要求，对使用方便的要求，对可维护性、可补充性、易读性、可靠性、运行环境可转换性的特殊要求等。 4运行环境规定4.1设备 列出运行该软件所需要的硬设备。说明其中的新型设备及其专门功能，包括： a．处理器型号及内存容量； b．外存容量、联机或脱机、媒体及其存储格式，设备的型号及数量； c．输入及输出设备的型号和数量，联机或脱机； d．数据通信设备的型号和数量； e．功能键及其他专用硬件 4.2支持软件 列出支持软件,包括要用到的操作系统、编译（或汇编）程序、测试支持软件等。 4.3接口 说明该软件同其他软件之间的接口、数据通信协议等。 4.4控制 说明控制该软件的运行的方法和控制信号，并说明这些控制信号的来源。 数据要求说明书数据要求说明书的编制目的是为了向整个开发时期提供关于被处理数据的描述和数据采集要求的技术信息。编制数据要求说明书的内容要求如下： 1引言1.1编写目的 说明编写这份数据要求说明书的目的，指出预期的读者。 1.2背景 说明： a. 待开发软件系统的名称； b．列出本项目的任务提出者、开发者、用户以及将运行该项软件的计算站（中心）或计算机网络系统。 1.3定义 列出本文件中用到的专门术语的定义和外文首字母组词的原词组。 1.4参考资料 列出有关的参考资料，如： a．本项目的经核准的计划任务书或合同，上级机关的批文； b．属于本项目的其他已发表文件； c．本文件中各处引用的文件、资料，包括所要用到的软件开发标准。列出这些文件的标题、文件编号、发表日期和出版单位。说明能够得到这些文件资料的来源。 2数据的逻辑描述 对数据进行逻辑描述时可把数据分为动态数据和静态数据。所谓静态数据，指在运行过程中主要作 为参考的数据，它们在很长的一段时间内不会变化，一般不随运行而改变。所谓动态数据．包括所有在运 行中要发生变化的数据以及在运行中要输入、输出的数据。进行描述时应把各数据元素逻辑地分成若干 组，列如函数、源数据或对于其应用更为恰当的逻辑分组。给出每一数据元的名称（包括缩写和代码）、定 义（或物理意义）度量单位、值域、格式和类型等有关信息。 2.1静态数据 列出所有作为控制或参考用的静态数据元素。 2.2动态输入数据 列出动态输入数据元素（包括在常规运行中或联机操作中要改变的数据）。 2.3动态输出数据 列出动态输出数据元素（包括在常规运行中或联机操作中要改变的数据）。 2.4内部生成数据 列出向用户或开发单位中的维护调试人员提供的内部生成数据。 2.5数据约定 说明对数据要求的制约。逐条列出对进一步扩充或使用方面的考虑而提出的对数据要求的限制（容 量、文卷、记录和数据元的个数的最大值）。对于在设计和开发中确定是临界性的限制更要明确指出。 3数据的采集3.1要求和范围 按数据元的逻辑分组来说明数据采集的要求和范围，指明数据的采集方法，说明数据采集工作的承担者是用户还是开发者。具体的内容包括： a．输入数据的来源，例如是单个操作员、数据输入站，专业的数据输入公司或它们的一个分组； b．数据输入（指把数据输入处理系统内部）所用的媒体和硬设备。如果只有指定的输入点的输入才是合法的，则必须对此加以说明； c．接受者说明输出数据的接受者； d．输出数据的形式和设备列出输出数据的形式和硬设备。无论接受者将接收到的数据是打印输出，还是CRT上的一组字符、一帧图形，或一声警铃，或向开关线圈提供的一个电脉冲，或常用介质如磁盘、磁带、穿孔卡片等，均应具体说明； e．数据值的范围给出每一个数据元的合法值的范围； f．量纲给出数字的度量单位、增量的步长、零点的定标等。在数据是非数字量的情况下，要给出每一种合法值的形式和含意； g．更新和处理的频度给出预定的对输入数据的更新和处理的频度。如果数据的输入是随机的，应给出更新处理的频度的平均值，或变化情况的某种其他度量 3.2输入的承担者 说明预定的对数据输入工作的承担者。如果输入数据同某一接口软件有关，还应说明该接口软件的来源。 3.3处理 对数据的采集和预处理过程提出专门的规定，包括适合应用的数据格式、预定的数据通信媒体和对输入的时间要求等。对于需经模拟转换或数字转换处理的数据量，要给出转换方法和转换因子等有关信息，以便软件系统使用这些数据。 3.4影响 说明这些数据要求对于设备、软件、用户、开发单位所可能产生的影响，例如要求用户单位增设某个机构等。 概要设计说明书概要设计说明书又可称系统设计说明书，这里所说的系统是指程序系统。编制的目的是说明对程序 系统的设计考虑，包括程序系统的基本处。流程、程序系统的组织结构、模块划分、功能分配、接口设计。 运行设计、数据结构设计和出错处理设计等，为程序的详细设计提供基础。编制概要设计说明书的内容 要求如下： 1引言1.1编写目的 说明编写这份概要设计说明书的目的，指出预期的读者。 1.2背景 说明： a．待开发软件系统的名称； b．列出此项目的任务提出者、开发者、用户以及将运行该软件的计算站（中心）。 1.3定义 列出本文件中用到的专门术语的定义和外文首字母组词的原词组。 1.4参考资料 列出有关的参考文件，如： a．本项目的经核准的计划任务书或合同，上级机关的批文； b．属于本项目的其他已发表文件； c．本文件中各处引用的文件、资料，包括所要用到的软件开发标准。 列出这些文件的标题、文件编号、发表日期和出版单位，说明能够得到这些文件资料的来源。 2总体设计2·1需求规定 说明对本系统的主要的输入输出项目、处理的功能性能要求 2.2运行环境 简要地说明对本系统的运行环境（包括硬件环境和支持环境）的规定 2.3基本设计概念和处理流程 说明本系统的基本设计概念和处理流程，尽量使用图表的形式。 2.4结构 用一览表及框图的形式说明本系统的系统元素（各层模块、子程序、公用程序等）的划分，扼要说明每个系统元素的标识符和功能，分层次地给出各元素之间的控制与被控制关系. 2.5功能需求与程序的关系 本条用一张如下的矩阵图说明各项功能需求的实现同各块程序的分配关系 2.6人工处理过程 说明在本软件系统的工作过程中不得不包含的人工处理过程（如果有的话）。 2.7尚未解决的问题 说明在概要设计过程中尚未解决而设计者认为在系统完成之前必须解决的各个问题。 3接口设计3.1用户接口 说明将向用户提供的命令和它们的语法结构，以及软件的回答信息。 3.2外部接口 说明本系统同外界的所有接口的安排包括软件与硬件之间的接口、本系统与各支持软件之间的接口关系。 3.3内部接口 说明本系统之内的各个系统元素之间的接口的安排。 4运行设计4.1运行模块组合 说明对系统施加不同的外界运行控制时所引起的各种不同的运行模块组合，说明每种运行所历经的内部模块和支持软件。 4.2运行控制 说明每一种外界的运行控制的方式方法和操作步骤。 4.3运行时间 说明每种运行模块组合将占用各种资源的时间。 5系统论据结构设计5.1逻辑结构设计要点 给出本系统内所使用的每个数据结构的名称、标识符以及它们之中每个数据项、记录、文卷和系的标识、定义、长度及它们之间的层次的或表格的相互关系。 5.2物理结构设计要点 给出本系统内所使用的每个数据结构中的每个数据项的存储要求，访问方法、存取单位、存取的物理关系（索引、设备、存储区域）、设计考虑和保密条件。 5.3数据结构与程序的关系 说明各个数据结构与访问这些数据结构的形式: 6系统出错处理设计6.1出错信息 用一览表的方式说朗每种可能的出错或故障情况出现时，系统输出信息的形式、含意及处理方法。 6.2补救措施 说明故障出现后可能采取的变通措施，包括： a.后备技术说明准备采用的后备技术，当原始系统数据万一丢失时启用的副本的建立和启动的技术，例如周期性地把磁盘信息记录到磁带上去就是对于磁盘媒体的一种后备技术； b．降效技术说明准备采用的后备技术，使用另一个效率稍低的系统或方法来求得所需结果的某些部分，例如一个自动系统的降效技术可以是手工操作和数据的人工记录； c．恢复及再启动技术说明将使用的恢复再启动技术，使软件从故障点恢复执行或使软件从头开始重新运行的方法。 6.3系统维护设计 说明为了系统维护的方便而在程序内部设计中作出的安排，包括在程序中专门安排用于系统的检查与维护的检测点和专用模块。 各个程序之间的对应关系，可采用如下的矩阵图的形式； 详细设计说明书详细设计说明书又可称程序设计说明书。编制目的是说明一个软件系统各个层次中的每一个程序 （每个模块或子程序）的设计考虑，如果一个软件系统比较简单，层次很少，本文件可以不单独编写，有关 内容合并入概要设计说明书。对详细设计说明书的内容要求如下： 1引言1.1编写目的 说明编写这份详细设计说明书的目的，指出预期的读者。 1.2背景 说明： a．待开发软件系统的名称； b.本项目的任务提出者、开发者、用户和运行该程序系统的计算中心。 1.3定义 列出本文件中用到专门术语的定义和外文首字母组词的原词组。 1.4参考资料 列出有关的参考资料，如： a．本项目的经核准的计划任务书或合同、上级机关的批文； b．属于本项目的其他已发表的文件； c.本文件中各处引用到的文件资料，包括所要用到的软件开发标准。 列出这些文件的标题、文件编号、发表日期和出版单位，说明能够取得这些文件的来源。 2程序系统的组织结构 用一系列图表列出本程序系统内的每个程序（包括每个模块和子程序）的名称、标识符和它们之间 的层次结构关系。 3程序1（标识符）设计说明 从本章开始，逐个地给出各个层次中的每个程序的设计考虑。以下给出的提纲是针对一般情况的。 对于一个具体的模块，尤其是层次比较低的模块或子程序，其很多条目的内容往往与它所隶属的上一层 模块的对应条目的内容相同，在这种情况下，只要简单地说明这一点即可。 3.1程序描述 给出对该程序的简要描述，主要说明安排设计本程序的目的意义，并且，还要说明本程序的特点（如 是常驻内存还是非常驻？是否子程序？是可重人的还是不可重人的？有无覆盖要求？是顺序处理还是并发处理等） 3.2功能 说明该程序应具有的功能，可采用IPO图（即输入一处理一输出图）的形式。 3.3性能 说明对该程序的全部性能要求，包括对精度、灵活性和时间特性的要求。 3.4输入项 给出对每一个输入项的特性，包括名称、标识、数据的类型和格式、数据值的有效范围、输入的方式。 数量和频度、输入媒体、输入数据的来源和安全保密条件等等。 3.5输出项 给出对每一个输出项的特性，包括名称、标识、数据的类型和格式，数据值的有效范围，输出的形式、 数量和频度，输出媒体、对输出图形及符号的说明、安全保密条件等等。 3.6算法 详细说明本程序所选用的算法，具体的计算公式和计算步骤。 3.7流程逻辑 用图表（例如流程图、判定表等）辅以必要的说明来表示本程序的逻辑流程。 3.8接口 用图的形式说明本程序所隶属的上一层模块及隶属于本程序的下一层模块、子程序，说明参数赋值和调用方式，说明与本程序相直接关联的数据结构（数据库、数据文卷）。 3.9存储分配 根据需要，说明本程序的存储分配。 3.10注释设计 说明准备在本程序中安排的注释，如： a. 加在模块首部的注释； b．加在各分枝点处的注释； 对各变量的功能、范围、缺省条件等所加的注释； d．对使用的逻辑所加的注释等等。 3.11限制条件 说明本程序运行中所受到的限制条件。 3.12测试计划. 说明对本程序进行单体测试的计划，包括对测试的技术要求、输入数据、预期结果、进度安排、人员职责、设备条件驱动程序及桩模块等的规定。 3.13尚未解决的问题 说明在本程序的设计中尚未解决而设计者认为在软件完成之前应解决的问题。 4程序2（标识符）设计说明…… 数据库设计说明书数据库设计说明书的编制目的是对于设计中的数据库的所有标识、逻辑结构和物理结构作出具体的设计规定。其内容要求如下： 1引言1.1编写目的 说明编写这份数据库设计说明书的目的，指出预期的读者。 1.2背景 说明： a．说明待开发的数据库的名称和使用此数据库的软件系统的名称； b·列出该软件系统开发项目的任务提出者、用户以及将安装该软件和这个数据库的计算站（中心)。 1.3定义 列出本文件中用到的专门术语的定义、外文首字母组词的原词组。 1.4参考资料 列出有关的参考资料： a．本项目的经核准的计划任务书或合同、上级机关批文； b．属于本项目的其他已发表的文件； c．本文件中各处引用到的文件资料，包括所要用到的软件开发标准。列出这些文件的标题、文件编号、发表日期和出版单位，说明能够取得这些文件的来源。 2外部设计2.1标识符和状态 联系用途，详细说明用于唯一地标识该数据库的代码、名称或标识符，附加的描述性信息亦要给出。如果该数据库属于尚在实验中、尚在测试中或是暂时使用的，则要说明这一特点及其有效时间范围。 2.2使用它的程序 列出将要使用或访问此数据库的所有应用程序，对于这些应用程序的每一个，给出它的名称和版本号。 2.3约定 陈述一个程序员或一个系统分析员为了能使用此数据库而需要了解的建立标号、标识的约定，例如 用于标识数据库的不同版本的约定和用于标识库内各个文卷、、记录、数据项的命名约定等。 2.4专门指导 向准备从事此数据库的生成、从事此数据库的测试、维护人员提供专门的指导，例如将被送入数据 库的数据的格式和标准、送入数据库的操作规程和步骤，用于产生、修改、更新或使用这些数据文卷的操 作指导。 如果这些指导的内容篇幅很长，列出可参阅的文件资料的名称和章条。 2.5支持软件 简单介绍同此数据库直接有关的支持软件，如数据库管理系统、存储定位程序和用于装入、生成、修 改、更新数据库的程序等。说明这些软件的名称、版本号和主要功能特性，如所用数据模型的类型、允许 的数据容量等。列出这些支持软件的技术文件的标题、编号及来源。 3结构设计3.1概念结构设计 说明本数据库将反映的现实世界中的实体、属性和它们之间的关系等的原始数据形式，包括各数据项、记录、系、文卷的标识符、定义、类型、度量单位和值域，建立本数据库的每一幅用户视图。 3.2逻辑结构设计 说明把上述原始数据进行分解、合并后重新组织起来的数据库全局逻辑结构，包括所确定的关键字和属性、重新确定的记录结构和文卷结构、所建立的各个文卷之间的相互关系，形成本数据库的数据库管理员视图。 3.3物理结构设计 建立系统程序员视图，包括： a．数据在内存中的安排，包括对索引区、缓冲区的设计； b．所使用的外存设备及外存空间的组织，包括索引区、数据块的组织与划分； c．访问数据的方式方法。 4运用设计4.1数据字典设计 对数据库设计中涉及到的各种项目，如数据项、记录、系、文卷、模式、子模式等一般要建立起数据字典，以说明它们的标识符、同义名及有关信息。在本节中要说明对此数据字典设计的基本考虑。 4.2安全保密设计 说明在数据库的设计中，将如何通过区分不同的访问者、不同的访问类型和不同的数据对象，进行分别对待而获得的数据库安全保密的设计考虑。 用户手册用户手册的编制是要使用非专门术语的语言，充分地描述该软件系统所具有的功能及基本的使用方法。使用户（或潜在用户）通过本手册能够了解该软件的用途，并且能够确定在什么情况下，如何使用它。具体的内容要求如下： 1引言1.1编写目的 说明编写这份用户手册的目的，指出预期的读者。 1.2背景 说明： a.这份用户手册所描述的软件系统的名称； b．该软件项目的任务提出者、开发者、用户（或首批用户）及安装此软件的计算中心。 1.3定义 列出本文件中用到的专门术语的定义和外文首字母组词的原词组。 1.4参考资料 列出有用的参考资料，如： a.项目的经核准的计划任务书或合同、上级机关的批文； b．属于本项目的其他已发表文件； c．本文件中各处引用的文件、资料，包括所要用到的软件开发标准。 列出这些文件资料的标题、文件编号、发表日期和出版单位，说明能够取得这些文件资料的来源。 2用途2.1功能 结合本软件的开发目的逐项地说明本软件所具有各项功能以及它们的极限范围。 2.2性能2.2.1精度 逐项说明对各项输入数据的精度要求和本软件输出数据达到的精度，包括传输中的精度要求。 2.2.2时间特性 定量地说明本软件的时间特性，如响应时间，更新处理时间，数据传输、转换时间，计算时间等。 2.2.3灵活性 说明本软件所具有的灵活性，即当用户需求（如对操作方式、运行环境、结果精度、时间特性等的要求）有某些变化时，本软件的适应能力。 2.3安全保密 说明本软件在安全、保密方面的设计考虑和实际达到的能力。 3运行环境3.1硬设备 列出为运行本软件所要求的硬设备的最小配置，如： a·处理机的型号、内存容量; b．所要求的外存储器、媒体、记录格式、设备的型号和台数、联机／脱机； c. I／O设备（联机／脱机？）； d．数据传输设备和转换设备的型号、台数。 3.2支持软件 说明为运行本软件所需要的支持软件，如： a．操作系统的名称、版本号； b．程序语言的编译／汇编系统的名称和版本号； c．数据库管理系统的名称和版本号； d．其他支持软件。 3.3数据结构 列出为支持本软件的运行所需要的数据库或数据文卷。 4使用过程 在本章，首先用图表的形式说明软件的功能同系统的输入源机构、输出接收机构之间的关系。 4.1安装与初始化 一步一步地说明为使用本软件而需进行的安装与初始化过程，包括程序的存储形式、安装与初始化过程中的全部操作命令、系统对这些命令的反应与答复。表征安装工作完成的测试实例等。如果有的话，还应说明安装过程中所需用到的专用软件。 4.2输入 规定输入数据和参量的准备要求。 4.2.1输入数据的现实背景 说明输入数据的现实背景，主要是 a. 情况——例如人员变动、库存‘缺货； b．情况出现的频度——例如是周期性的、随机的、一项操作状态的函数． c．情况来源—一例如人事部门、仓库管理部门； d．输入媒体———例如键盘、穿孔卡片、磁带； e．限制——出于安全、保密考虑而对访问这些输入数据所加的限制； f．质量管理——例如对输入数据合理性的检验以及当输入数据有错误时应采取的措施，如建立出错情况的记录等； g．支配——例如如何确定输入数据是保留还是废弃，是否要分配给其他的接受者等。 4.2.2输入格式 说明对初始输入数据和参量的格式要求，包括语法规则和有关约定，如： a．长度—一例如字符数／行，字符数／项； b．格式基准——例如以左面的边沿为基准； c．标号——例如标记或标识符； d．顺序——例如各个数据项的次序及位置； e· 标点——例如用来表示行、数据组等的开始或结束而使用的空格、斜线、星号、字符组等。 f． 词汇表——给出允许使用的字符组合的列表，禁止使用＊的字符组合的列表等； g．省略和重复——给出用来表示输人元素可省略或重复的表示方式； h．控制——给出用来表示输入开始或结束的控制信息。 4.2.3输入举例 为每个完整的输入形式提供样本，包括： a．控制或首部——例如用来表示输入的种类和类型的信息，标识符输入日期，正文起点和对所用编码的规定； b．主体——输入数据的主体，包括数据文卷的输入表述部分； c．尾部——用来表示输入结束的控制信息，累计字符总数等； d．省略——指出哪些输入数据是可省略的； e．重复——指出哪些输入数据是重复的。 4.3输出 对每项输出作出说明. 4.3.1输出数据的现实背景 说明输出数据的现实背景，主要是： a．使用——这些输出数据是给谁的，用来干什么； b·使用频度——例如每周的、定期的或备查阅的； c．媒体——打印、CRI显示、磁带、卡片、磁盘， d．质量管理—一例如关于合理性检验、出错纠正的规定； e．支配——例如如何确定输出数据是保留还是废弃，是否要分配给其他接受者等。 4.3.2输出格式 给出对每一类输出信息的解释，主要是： a．首部——如输出数据的标识符，输出日期和输出编号； b．主体——输出信息的主体，包括分栏标题； c．尾部——包括累计总数，结束标记。 4.3.3输出举例 为每种输出类型提供例子。对例子中的每一项，说明： a．定义——每项输出信息的意义和用途； b．来源——是从特定的输入中抽出、从数据库文卷中取出、或从软件的计算过程中得到； c．特性——输出的值域、计量单位、在什么情况下可缺省等。 4.4文卷查询 这一条的编写针对具有查询能力的软件，内容包括：同数据库查询有关的初始化、准备、及处理所需 要的详细规定，说明查询的能力、方式，所使用的命令和所要求的控制规定。 4.5出错处理与恢复 列出由软件产生的出错编码或条件以及应由用户承担的修改纠正工作。指出为了确保再启动和恢 复的能力，用户必须遵循的处理过程。 4.6终端操作 当软件是在多终端系统上工作时，应编写本条，以说明终端的配置安排、连接步释、数据和参数输入 步骤以及控制规定．说明通过终端操作进行查询、检索、修改数据文卷的能力、语言、过程以及辅助性程 序等。 操作手册操作手册的编制是为了向操作人员提供该软件每一个运行的具体过程和有关知识，包括操作方法的细节。具体的内容要求如下： 1引言1.1编写目的 说明编写这份操作手册的目的，指出预期的读者。 1.2背景 说明： a．这份操作手册所描述的软件系统的名称； b．该软件项目的任务提出者、开发者、用户（或首批用户）及安装该软件的计算中心。 1.3定义 列出本文件中用到的专门术语的定义和外文首字母组词的原词组。 1.4参考资料 列出有用的参考资料，如： a．本项目的经核准的计划任务书或合同、上级机关的批文； b·属于本项目的其他已发表的文件； c．本文件中各处引用的文件、资料，包括所列出的这些文件资料的标题、文件编号、发表日期和出 版单位，说明能够得到这些文件资料的来源。 2.软件概述2.1软件的结构 结合软件系统所具有的功能包括输入、处理和输出提供该软件的总体结构图表。 2.2程序表 列出本系统内每个程序的标识符、编号和助记名。 2.3文卷表 列出将由本系统引用、建立或更新的每个永久性文卷，说明它们各自的标识符、编号、助记名、存储 媒体和存储要求。 3安装与初始化 一步一步地说明为使用本软件而需要进行的安装与初始化过程，包括程序的存载形式，安装与初始 化过程中的全部操作命令，系统对这些命令的反应与答复，表征安装工作完成的测试实例等。如果有的 话，还应说明安装过程中所需用到的专用软件。 4运行说明 所谓一个运行是指提供一个启动控制信息后，直到计算机系统等待另一个启动控制信息时为止的 计算机系统执行的全部过程。 4.1运行表 列出每种可能的运行，摘要说明每个运行的目的，指出每个运行各自所执行的程序。 4.2运行步骤 说明从一个运行转向另一个运行以完成整个系统运行的步骤。 4.3运行1（标识符）说明 把运行1的有关信息，以对操作人员为最方便最有用的形式加以说明。 4.3.1运行控制 列出为本运行所需要”的运行流向控制的说明。 4.32操作信息 给出为操作中心的操作人员和管理人员所需要的信息，如： a. 运行目的； b．操作要求； c. 启动方法 如应请启动（由所遇到的请求信息启动）、预定时间启动、…，··等； d．预计的运行时间和解题时间； 操作命令； f．与运行有联系的其他事项。 4.33输入一输出文卷 提供被本运行建立、更新或访问的数据文卷的有关信息，如： a. 文卷的标识符或标号； b·记录媒体； c.存留的目录表； d．文卷的支配如确定保留或废弃的准则、是否要分配给其他接受者、占用硬设备的优先级以及 保密控制等有关规定。 4.3.4输出文段 提供本软件输出的每一一个用于提示、说明、或应答的文段（包括“菜单”）的有关信息，如： a. 文段的标识符； b．输出媒体（屏幕显示、打印、……）； c. 文字容量； d．分发对象； e. 保密要求。 4.3.5输出文段的复制 对由计算机产生，而后需用其他方法复制的那些文段提供有关信息，如： a. 文段的标识符； b．复制的技术手段； c. 纸张或其他媒体的规格； d．装订要求； e. 分发对象； f．复制份数。 4.36启动恢复过程 说明本运行故障后的恢复过程。 4.4运行2（标识符）说明…… 5非常现过程 提供有关应急操作或非常规操作的必要信息，如出错处理操作、向后备系统的切换操作以及其他必 须向程序维护人员交待的事项和步骤。 6远程操作 如果本软件能够通过远程终端控制运行，则在本章说明通过远程终端运行本软件的操作过程。 模块开发卷宗模块开发卷宗是在模块开发过程中逐步编写出来的，每完成一个模块或一组密切相关的模块的复审时编写一份，应该把所有的模块开发卷宗汇集在一起。编写的目的是记录和汇总低层次开发的进度和结果，以便于对整个模块开发工作的管理和复审，并为将来的维护提供非常有用的技术信息。具体的内容要求如下： 1标题 软件系统名称和标识符 模块名称和标识符（如果本卷宗包含多于一个的模块，则用这组模块的功能标识代替模块名） 程序编制员签名 卷宗的修改文本序号 修改完成日期 卷宗序号（说明本卷宗在整个卷宗中的序号） 编排日期（说明整个卷宗最近的一次编排日期） 2模块开发情况表（见下表） 3功能说明 扼要说明本模块（或本组模块）的功能，主要是输入、要求的处理、输出。可以从系统设计说明书中摘录。同时列出在软件需求说明书中对这些功能的说明的章、条、款。 4设计说明 说明本模块（或本组模块）的设计考虑，包括： a．在系统设计说明书中有关对本模块（或本组模块）设计考虑的叙述，包括本模块在软件系统中所处的层次，它同其他模块的接口； b．在程序设计说明书中有关对本模块（或本组模块）的设计考虑，包括本模块的算法、处理流程、牵涉到的数据文卷设计限制、驱动方式和出错信息等； c．在编制目前已通过全部测试的源代码时实际使用的设计考虑。 5源代码清单 要给出所产生的本模块（或本组模块）的第一份无语法错的源代码清单以及已通过全部测试的当前有效的源代码清单。 6测试说明 说明直接要经过本模块（或本组模块）的每一项测试，包括这些测试各自的标识符和编号、进行这些测试的目的、所用的配置和输入、预期的输出及实际的输出。 7复审的结论 把实际测试的结果，同软件需求说明书、系统设计说明书、程序设计说明书中规定的要求进行比较和给出结论。 测试计划这里所说的测试，主要是指整个程序系统的组装测试和确认测试。本文件的编制是为了提供一个对该软件的测试计划，包括对每项测试活动的内容、进度安排、设计考虑、测试数据的整理方法及评价准则。具体的内容要求如下： 1引言1.1编写目的 本测试计划的具体编写目的，指出预期的读者范围。 1.2背景 说明： a 测试计划所从属的软件系统的名称； b．该开发项目的历史，列出用户和执行此项目测试的计算中心，说明在开始执行本测试计划之前必须完成的各项工作。 1.3定义 列出本文件中用到的专门术语的定义和外文首字母组词的原词组。 1.4参考资料 列出要用到的参考资料，如： a．本项目的经核准的计划任务书或合同、上级机关的批文； b．属于本项目的其他已发表的文件； c．本文件中各处引用的文件、资料，包括所要用到的软件开发标准。 列出这些文件的标题、文件编号、发表日期和出版单位，说明能够得到这些文件资料的来源。 2计划2.1软件说明 提供一份图表，并逐项说明被测软件的功能、输入和输出等质量指标，作为叙述测试计划的提纲。 2.2测试内容 列出组装测试和确认测试中的每一项测试内容的名称标识符、这些测试的进度安排以及这些测试的内容和目的，例如模块功能测试、接口正确性测试、数据文卷存取的测试、运行时间的测试、设计约束和极限的测试等。 2.3测试1（标识符） 给出这项测试内容的参与单位及被测试的部位。 2.3.1进度安排 给出对这项测试的进度安排，包括进行测试的日期和工作内容（如熟悉环境。培训、准备输入数据等）。 2.3.2条件 陈述本项测试工作对资源的要求，包括： a．设备所用到的设备类型、数量和预定使用时间； b．软件列出将被用来支持本项测试过程而本身又并不是被测软件的组成部分的软件，如测试驱动程序、测试监控程序、仿真程序、桩模块等等； c．人员列出在测试工作期间预期可由用户和开发任务组提供的工作人员的人数。技术水平及有关的预备知识，包括一些特殊要求，如倒班操作和数据键入人员。 2.3.3测试资料 列出本项测试所需的资料，如： a．有关本项任务的文件； b·被测试程序及其所在的媒体； c．测试的输入和输出举例； d．有关控制此项测试的方法、过程的图表。 2.34测试培训 说明或引用资料说明为被测软件的使用提供培训的计划。规定培训的内容、受训的人员及从事培训的工作人员。 2.4测试2（标识符）……3测试设计说明3.1测试l（标识符） 说明对第一项测试内容的测试设计考虑。 3.1.1控制 说明本测试的控制方式，如输入是人工、半自动或自动引入、控制操作的顺序以及结果的记录方法。 3.1.2输入 说明本项测试中所使用的输入数据及选择这些输入数据的策略。 3.1.3输出 说明预期的输出数据，如测试结果及可能产生的中间结果或运行信息。 3.1.4过程 说明完成此项测试的一个个步骤和控制命令，包括测试的准备、初始化、中间步聚和运行结束方式。 3.2测试2（标识符）…….4评价准则4.1范围 说明所选择的测试用例能够接查的范围及其局限性。 4.2数据整理 陈述为了把测试数据加工成便于评价的适当形式，使得测试结果可以同，已知结果进行比较而要用到的转换处理技术，如手工方式或自动方式；如果是用自动方式整理数据，还要说明为进行处理而要用到的硬件、软件资源。 4.3尺度 说明用来判断测试工作是否能通过的评价尺度，如合理的输出结果的类型、测试输出结果与预期输出之间的容许偏离范围、允许中断或停机的最大次数。 测试分析报告测试分析报告的编写是为了把组装测试和确认测试的结果、发现及分析写成文件加以记载，具体的内容要求如下： 1引言1.1编写目的 说明这份测试分析报告具体编写目的，指出预期阅读范围。 1.2背景 说明：a. 被测试软件系统的名称b. 该软件的任务提出者、开发者、用户、及安装此软件的计算中心，指出测试环境与实际运行环境主键可能存在的差异以及这些差异对测试结果的影像。 1.3定义 列出本文件中用到的专门术语的定义和外文首字母组词的原词组。 1.4参考资料 列出用到的参考资料a. 本项目的经核准的计划任务书、合同、上级机关批文。b. 属于本项目的其他已发表的文件。c. 本文中各处引用的文件、资料、包括所要用到的软件开发标准。列出这些文件的标题、文件编号、发表日期和出版单位，说明能够得到这些资料的来源。 2测试概要 用表格的形式列出每一项测试的标识符及其测试内容，并指明实际进行测试的测试工作内容与测试计划中预先设计的内容之间的差别，说明做出这种改变的原因。 3测试结果及发现3.1测试1（标识符） 把本项测试中实际得到的动态输出（包括内部生成数据输出）结果同对于动态输出的要求进行比较，陈述其中的各项发现。 3.2测试2（标识符）……4对软件功能的结论4.1功能1（标识符）4.1.1能力 简述该项的功能，说明为满足此项功能而设计的软件能力以及经过一项或多项测试已证实的能力。 4.1.2限制 说明测试数据值的范围（包括动态数据和静态数据），列出就这项功能而言，测试期间在该软件中查出的缺陷和局限性。 4.2功能2（标识符）5分析摘要5.1能力 陈述经测试证实了的本软件的能力。如果所进行的测试是为了验证一项或几项特定性能要求的实现，应提供这方面的测试结果与要求之间的比较，并确定测试环境与实际运行环境之间可能存在的差异对能力的测试所带来的影响。 5.2缺陷和限制 陈述经测试证实的软件缺陷和限制，说明每项缺陷和限制对软件性能的影响，并说明全部测得的性能缺陷的累积影响和总影响。 5.3建议 对每项缺陷提出改进建议如：a. 各项修改可采用的修改方法。b. 各项修改的紧迫程度。c. 各项修改预计的工作量d.各项修改的负责人。 5.4评价 说明该软件的开发是否已达到预定目标，能否交付使用。 6测试资源消耗 总结测试工作的资源消耗数据，如工作人员的水平级别数量、机时消耗等。 开发进度月报开发进度月报的编制目的是及时向有关管理部门汇报项目开发的进展和情况，以便及时发现和处 理开发过程中出现的问题。一般地，开发进度月报是以项目组为单位每月编写的。如果被开发的软件系 统规模比较大，整个工程项目被划分给若干个分项目组承担，开发进度月报将以分项目组为单位按月编 写。具体的内容要求如下： 1标题 开发中的软件系统的名称和标识符分项目名称和标识符分项目负责人签名本期月报编写人签名本期月报的编号及所报告的年月 2工程进度与状态2.1进度 列出本月内进行的各项主要活动，并且说明本月内遇到的重要事件，这里所说的重要事件是指一个开发阶段（即软件生存周期内各个阶段中的某一个，例如需求分析阶段）的开始和结束，要说明阶段名称及开始或结束的日期。 2.2状态 说明本月的实际工作进度与计划相比，是提前了、按期完成了、或是推迟了。如果与计划不一致，说明原因及准备采取的措施。 3资源耗用与状态3.1资源耗用 主要说明本月份内耗用的工时与机时。 3.1.1工时 分为三类：a. 管理用工时，包括在项目管理（制定计划、布置工作、收集数据、检查汇报工作等）方面耗用的工时。b. 服务工时，包括为支持项目开发所必需的服务工作及非直接的开发工作所耗用的工时。c. 开发用工时，要分各个开发阶段填写。 3.1.2机时 说明本月内耗用的机时，以小时为单位说明计算机系统的型号。 3.2状态 说明本月内实际耗用的资源与计划相比，是超出了、一致、还是不到计划数。如果与计划不一致。说明原因及准备采取的措施。 4经费支出与状态4.1经费支出4.1.1支持性费用 列出本月内的支持性费用，一般可按如下七类列出，并给出本月支持费用的总和。a. 房租或房屋折旧费b. 工资奖金补贴c. 培训费，包括给教师的酬金及教室租金d. 资料费，包括复印及购买参考资料的费用e. 会议费，召集业务会议的费用f. 差旅费g. 其他费用 4.1.2设备购置费 列出本月内支出的设备购置费，一般可分为以下三类：a. 购买软件的名称与金额b. 购买硬设备的名称、型号、数量及金额c. 已有硬设备的折旧费 4.2状态 说明本月内实际支出的经费与计划相比较，是超出了、一致、还是不到计划数。如果与计划不一致。说明原因及准备采取的措施。 5下个月的工作计划6建议 本月遇到的重要问题和应引起重视的问题以及因此产生的建议。 项目开发总结报告1引言1.1编写目的 说明编写这份项目开发总结报告的目的，指出预期的阅读范围。 1.2背景 说明：a. 项目的名称和所开发出来的软件系统的名称。b. 本此软件的任务提出者、开发者、用户及安装此软件的计算中心。 1.3定义 列出本文件中用到的专门术语的定义和外文首字母组词的原词组。 1.4参考资料 列出用到的参考资料a. 本项目的经核准的计划任务书、合同、上级机关批文。b. 属于本项目的其他已发表的文件。c. 本文中各处引用的文件、资料、包括所要用到的软件开发标准。列出这些文件的标题、文件编号、发表日期和出版单位，说明能够得到这些资料的来源。 2实际开发结果2.1产品 说明最终制成的产品，包括：a.程序系统中各个程序的名字，他们之间的层次关系，以千字节为单位的各个程序的程序量、存储媒体的形式和数量。b.程序系统共有哪几个版本，各自的版本号及区别。c.每个文件的名称。d.所建立的每个数据库。 2.2主要功能和性能 逐项列出本软件产品所实际具有的主要功能和性能，对照可行性研究报告、项目开发计划、功能需求说明书的有关内容，说明原定的开发目标是达到了、未完全达到、或超过了。 2.3基本流程 用图给出本程序系统的实际的基本处理流程 2.4进度 列出原定计划进度与实际进度的对比，明确说明，实际进度是提前了、还是迟了，析主要原因。 2.5费用 列出原定计划费用与实际支出费用的对比，包括：a.工时，以人月为单位，并按不同级别统计。b.计算机的使用时间，区别cpu时间及其他设备时间。c.物料消耗、出差费等其他支出。明确说明经费是超出了还是结余了，分析主要原因。 3开发工作评价3.1对生产效率的评价 给出实际生产效率包括：a.程序的平均生产效率，即每人月生产的行数。b.文件的平均生产效率，即每人月产生的千字数。 3.2对产品质量的评价 说明在测试中检查出来的程序编制中的错误发生率，即每千条指令（或语句）中的错误指令数。如果开发中制定过质量保证计划或配置管理计划，要同这些计划相比较。 3.3对技术方法的评价 给出对在开发中所使用的技术、方法、工具、手段的评价。 3.4出错原因的分析 给出对于开发中出现的错误的原因分析 4经验与教训 列出从这项开发工作中所得到的最主要的经验与教训及对今后的项目开发工作的建议","categories":[{"name":"开发文档","slug":"开发文档","permalink":"http://yxqblog.tk/categories/开发文档/"}],"tags":[{"name":"开发文档","slug":"开发文档","permalink":"http://yxqblog.tk/tags/开发文档/"},{"name":"国标","slug":"国标","permalink":"http://yxqblog.tk/tags/国标/"}]},{"title":"shp2pgsql工具详解","slug":"shp2pgsql","date":"2018-03-27T16:00:00.000Z","updated":"2018-03-28T13:35:45.822Z","comments":true,"path":"2018/03/28/shp2pgsql/","link":"","permalink":"http://yxqblog.tk/2018/03/28/shp2pgsql/","excerpt":"","text":"摘要翻译至PostGis 2.4.4 Dev Manual 4.4.2 有删减。英文水平有限，错漏之处敬请告知。 shp2pgsql 是PostgreSQL提供的入库工具。能够将 ESRI Shape file转换成可插入PostGIS/PostgreSQL的SQL语句。虽然PostGIS提供了可视化的入库工具shp2pgsql-gui，但易用性欠佳。我们可以通过熟悉shp2pgsql然后开发易用的shape file入库工具。 shp2pgsql-gui 用法shp2pgsql包含多个命令参数，用于指定导入配置。参数列表如下： 以下四个为互斥选项 -c 创建新的表结构并填充数据。默认选项。 -a 将shp文件中的数据导入已存在的数据表中。使用此选项文件必须具有相同的字段和数据类型。 -d 创建新表和导入数据前，删除数据库中已存在的表。 -p 只生成创建表结构的SQL代码，不导入任何数据。当需要分离表结构创建和数据导入时，使用此项。 其他参数 -? 查看帮助信息 -D 使用PostgreSQL “dump”格式输出数据。可以和-a、-c及-d结合使用。“dump”加载速度比“insert”快很多，可以用于大数据量的数据集处理。 -s &lt;[&lt;FROM_SRID&gt;] 以指定的SRID创建表结构并填充数据。可以为给定的FROM_SRID指定任意的shp文件，此时空间数据会被重投影到目标SRID。FROM_SRID不能用-D来指定。 -k 保持标识符大小写（列，模式和属性 ）。shp中的属性字段都是大写。 -i 强制所有整型数据为标准32位整数，即使DBF头文件标名也不创建64位的bigints -I 在空间数据列上创建GiST空间索引。 -m 指定一个文件包含长列名与DBF列名（译者注：DBF文件支持的列名长度不大于10）的映射.文件内容是一个或多个两行名称，以空格分隔，前后无空格。例如： 123&gt; COLUMNNAME DBFFIELD1&gt; AVERYLONGCOLUMNNAME DBFFIELD2&gt; -S 创建简单的几何对象而不是MULTI几何对象。只有shp数据中所有feature都为简单对象时才能成果（比如MULTIPOLYGON只包含一个面，MULTIPOINT只包含一个点）。 -t 强制输出具有指定维度的空间几何数据。使用以下字符串表示维度：2D、3dz、3SM、4d。 如果输入shp文件维度小于指定维度，输出数据中缺少的维度将以0填充。如果输入的shp文件维度大于指定维度，多余维度将被舍去。 -w 以WKT格式输出，而不是WKB。请注意，由于精度损失可能导致数据偏移。 -e 在不使用事务的情况下独立执行每个语句。这样，当一部分几何图形产生错误时，仍然可以加载其余数据。注意，这不能和-D一起使用，因为“dump”格式总是使用事务。 -W 指定输入矢量文件（DBF文件）的编码格式。使用时，所有的DBF数据都会从指定编码转换成UTF-8。输出的SQL文件将包含一条命令：SET CLIENT_ENCODING to UTF8，这样后台就能将数据从UTF-8转换成数据库内部使用的任意编码。 -N 空几何类型的处理策略（插入*、跳过或终止） -n 只导入DBF文件的数据。如果矢量文件没有对应的.shp图形就，将自动切换到该模式，只导入DBF。所以只有矢量文件完整且只希望导入属性表不导入几何图形的情况才需要使用该模式。 -G 在WGS84经纬度参考（SRID=4326）中使用geography类型，而不是geometry。 -T 为新创建的表指定表空间。除非使用了-X参数，否则索引仍将使用默认表空间。关于何时使用自定义表空间PostgreSQL文档有详细说明。 -X 为新创建的表索引指定表空间。适用于主键索引，当使用-I参数时也适用于GIST空间索引 示例使用shp2pgsql创建SQL文件并导入数据库的过程如下所示： 12# shp2pgsql -c -D -s 4269 -i -I shaperoads.shp myschema.roadstable &gt; roads.sql# psql -d roadsdb -f roads.sql 使用UNIX管道可以在 一个命令中完成矢量数据转换和入库： 1# shp2pgsql shaperoads.shp myschema.roadstable | psql -d roadsdb 了解更多了解更多关于PostGIS的内容请参阅以下链接： PostGIS 2.4.4 Dev Manual","categories":[{"name":"Postgresql","slug":"Postgresql","permalink":"http://yxqblog.tk/categories/Postgresql/"}],"tags":[{"name":"Shp","slug":"Shp","permalink":"http://yxqblog.tk/tags/Shp/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"http://yxqblog.tk/tags/PostgreSQL/"},{"name":"PostGIS","slug":"PostGIS","permalink":"http://yxqblog.tk/tags/PostGIS/"}]},{"title":"常用软件开发文档及英文缩写","slug":"Dev-Doc","date":"2018-03-25T16:00:00.000Z","updated":"2018-03-28T13:27:39.927Z","comments":true,"path":"2018/03/26/Dev-Doc/","link":"","permalink":"http://yxqblog.tk/2018/03/26/Dev-Doc/","excerpt":"","text":"摘要软件项目开发过程中，应该具有完备的文档支持，文档编制要求具有针对性、精确性、清晰性、完整性、灵活性和可追溯行。完备的文档对软件开发及使用起到很大的作物。一般情况要求编写好以下几种文档（视情况增减）。 常用开发文档 可行性分析报告 说明该软件开发项目的实现在技术上、经济上和社会因素上的可行性，评述为了合理地达到开发目标可供选择的各种可能实施方案，说明并论证所选定实施方案的理由。 软件开发计划 为软件项目实施方案制订出具体计划，应该包括各部分工作的负责人员、开发的进度、开发经费的预算、所需的硬件及软件资源等。 软件需求规格说明） 对所开发软件的功能、性能、用户界面及运行环境等作出详细的说明。它是在用户与开发人员双方对软件需求取得共同理解并达成协议的条件下编写的，也是实施开发工作的基础。该说明书应给出数据逻辑和数据采集的各项要求，为生成和维护系统数据文件做好准备。 软件概要设计说明 是概要设计阶段的工作总结。主要包括功能分配、模块划分、程序总体结构、输入输出以及接口设计、运行设计、数据结构设计和出错处理等，为详细设计作好准备。 软件详细设计说明 着重描述每一模块是怎样实现的，包括实现算法、逻辑流程等。 数据库设计说明 数据库 顶层设计、包括存取 操纵数据库使用的软件配置项等 软件用户手册 详细描述了该软件的功能、性能和用户界面，使用该软件的具体方法等。 软件测试说明 描述执行计算机软件配置项CSCI,系统或子系统合格性测试所用到的测试准备、测试用例及测试过程。 软件测试计划 包括测试内容、进度、条件、人员、测试用例的选取原则、测试结果允许的偏差范围等。 软件测试报告 测试计划的执行情况，对测试结果的分析，提出测试结论。 开发进度月报 按月提交的项目进展情况报告。包括计划与实际执行情况的对比、阶段成果、遇到的问题、解决的方法以及下一步的打算。 项目开发总结报告 项目完成以后，总结实际执行情况。如进度、成果、资源利用、成本和投入的人力，对项目开发作出评价，总结经验与教训。 软件维护手册 主要包括软件系统说明、程序模块说明、操作环境、支持软件说明、维护过程说明等。 软件问题报告 记录软件出现问题的日期、发现人、状态、问题所属模块等，为软件修改提供准备文档。 软件修改报告 软件产品投入使用后，发现了需修改、更正的问题，要将出现的问题、修改意见、修改可能 出现影响作出详细描述，提交审批。 中英文名称及缩写 中文名称 英文名称 英文缩写 可行性分析报告 Feasibility Analysis Report FAR 软件开发计划 Software Development Plan SDP 软件需求规格说明 Software Requirements Specification SRS 概要设计说明 Preliminary Design Document PDD 详细设计说明 Detailed Design Document DDD 数据库设计说明 Database Design Description DBDD 软件用户手册 Software User’s Manual SUM 软件测试说明 Software Testing Description STD 软件测试计划 Software Testing Plan STP 软件测试报告 Software Test Report STR 开发进度月报 Development Progress Monthly Report DPMR 项目开发总结报告 Project Development Summary Report PDSR 软件维护手册 Software Maintenance Manual SMM 软件问题报告 Software Problem Report SPR 软件修改报告 Software Change Report SCR","categories":[{"name":"开发文档","slug":"开发文档","permalink":"http://yxqblog.tk/categories/开发文档/"}],"tags":[{"name":"开发文档","slug":"开发文档","permalink":"http://yxqblog.tk/tags/开发文档/"}]},{"title":"书籍推荐-《花香满径》（爱尔兰）巴克莱","slug":"book-hxmj","date":"2018-03-24T16:00:00.000Z","updated":"2018-03-25T12:17:02.456Z","comments":true,"path":"2018/03/25/book-hxmj/","link":"","permalink":"http://yxqblog.tk/2018/03/25/book-hxmj/","excerpt":"","text":"推荐高中时期初读此书，只拿来当是课外消遣。第一节印象深刻： 幸福的生活有三个不可缺的因素：一是有希望。二是有事做。三是能爱人。 彼时年少，未曾深思。如今已近而立之年。重拾此书，颇有感慨。 封面 摘录 一月一日 幸福幸福的生活有三个不可缺的因素：一是有希望。二是有事做。三是能爱人。有希望。亚历山大大帝有一次大送礼物，表示他的慷慨。他给了甲一大笔钱，给了乙一个省份，给了丙一个高官，他的朋友听到这件事后，对他说：“你要是一直这样做下去，你自己会一贫如洗。”亚历山大回答说：“我哪会一贫如洗，我为我自己留下的是一份最伟大的礼物。我所留下的是我的希望。”一个要是只生活在回忆中，却失去了希望，他的生命已经开始终结。回忆不能鼓舞我们有力的生活下去，回忆只能让我们逃避，好像囚犯逃出监狱。有事做。一个英国老妇人，在她重病自知时日不多的时候，写下了如下的诗句：现在别怜悯我，永远也不要怜悯我，我将不再工作，永远永远不再工作。很多人都有过失业，或者没事的时候，他就会觉得日子过得很慢生活十分的空虚。有过这种经验的人都会知道，有工作不是不幸，而是一种幸福。能爱人。诗人白朗宁曾写道：“他望了她一眼，她对他回眸一笑，生命突然苏醒。”生命中有了爱，我们就会变得焕发、谦卑、有生气，新的希望油然而生，仿佛有千百件事等着我们去完成。有了爱，生命就有了春天，世界也变得万紫千红。","categories":[{"name":"Book","slug":"Book","permalink":"http://yxqblog.tk/categories/Book/"}],"tags":[{"name":"Book","slug":"Book","permalink":"http://yxqblog.tk/tags/Book/"}]},{"title":"Git SSH 配置及使用","slug":"Git-SSH-配置及使用","date":"2017-07-14T16:00:00.000Z","updated":"2018-04-05T08:29:09.990Z","comments":true,"path":"2017/07/15/Git-SSH-配置及使用/","link":"","permalink":"http://yxqblog.tk/2017/07/15/Git-SSH-配置及使用/","excerpt":"","text":"在管理Git项目上，很多时候都是直接使用https url克隆到本地，当然也有有些人使用SSH url克隆到本地。 这两种方式的主要区别在于：使用https url克隆对初学者来说会比较方便，复制https url然后到git Bash里面直接用clone命令克隆到本地就好了，但是每次fetch和push代码都需要输入账号和密码，这也是https方式的麻烦之处。 而使用SSH url克隆却需要在克隆之前先配置和添加好SSH key，因此，如果你想要使用SSH url克隆的话，你必须是这个项目的拥有者。否则你是无法添加SSH key的，另外ssh默认是每次fetch和push代码都不需要输入账号和密码，如果你想要每次都输入账号密码才能进行fetch和push也可以另外进行设置。前面的几篇介绍Git的博客里面采用的都是https的方式作为案例， 今天主要是讲述如何配置使用ssh方式来提交和克隆代码。 大概可以分为一下几个步骤 设置Git的user name和email：(如果是第一次的话) 检查是否已经有SSH Key。 生成密钥 添加密钥到ssh-agent 登陆Github, 添加 ssh 测试： 设置Git的user name和email1234# 这里的“xujun&quot; 可以替换成自己的用户名git config --global user.name &quot;xujun&quot;# 这里的邮箱 gdutxiaoxu@163.com 替换成自己的邮箱git config --global user.email &quot;gdutxiaoxu@163.com&quot; 检查是否已经有SSH Key12cd ~/.sshls 列出该文件下的文件，看是否存在 id_isa 和 id_isa.pub 文件（也可以是别的文件名，只要 yourName 和 yourName.pub 成对存在），如果存在的话，证明已经存在 ssh key了，可以直接跳过 生成密钥 这一步骤，下图是存在的情况 生成密钥12# 这里的邮箱 name@mail.com 替换成自己的邮箱ssh-keygen -t rsa -C &quot;name@mail.com&quot; 连续3个回车。如果不需要密码的话。最后得到了两个文件：id_rsa和id_rsa.pub。 默认的存储路径是： 1C:\\Users\\Administrator\\.ssh 添加密钥到ssh-agent确保 ssh-agent是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。 12# start the ssh-agent in the backgroundeval &quot;$(ssh-agent -s)&quot; 添加生成的 SSH key 到 ssh-agent。 1ssh-add ~/.ssh/id_rsa 登陆Github, 添加 ssh把id_rsa.pub文件里的内容复制到这里 测试：1ssh -T git@github.com 你将会看到： 1Hi humingx! You’ve successfully authenticated, but GitHub does not provide shell access. 如果看到Hi后面是你的用户名，就说明成功了。 扩展如果我之前的仓库是用https提交的，那么我现在想用ssh 的方式提交，怎么办呢 ，别急，下面就来教你怎样操作了。 这里同样以我本机目录下的G://test 仓库为例子， 找到仓库下 .git 文件夹下的config文件，打开，可以看到以下内容 12345678910111213[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote &quot;origin&quot;] url = https://github.com/yourname/test.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master 将文件中的 url = https://github.com/yourname/test.git 更改为 url = git@github.com:yourname/test.git 即可。 修改后的文件如下 12345678910111213[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote &quot;origin&quot;] url = git@github.com:gdutxiaoxu/test.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master","categories":[{"name":"版本控制","slug":"版本控制","permalink":"http://yxqblog.tk/categories/版本控制/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yxqblog.tk/tags/Git/"},{"name":"Github","slug":"Github","permalink":"http://yxqblog.tk/tags/Github/"},{"name":"SSH","slug":"SSH","permalink":"http://yxqblog.tk/tags/SSH/"}]},{"title":"QT调用WebService的尝试和最终实现","slug":"cpp-call-webservice","date":"2017-06-20T16:00:00.000Z","updated":"2018-03-25T07:16:33.149Z","comments":true,"path":"2017/06/21/cpp-call-webservice/","link":"","permalink":"http://yxqblog.tk/2017/06/21/cpp-call-webservice/","excerpt":"","text":"最近接触的QT项目与平台对接时需要用到WebService。博主从毕业起大部分工作都是在做桌面开发，所以对WebService只能说是一知半解。唯一的接触就是在.NET平台下编写，发布和调用WebService。这其中大部分工作微软都帮我们做好了，我们只需添加web引用，就像引用本地的库一样。不得不说VS确实强大且易用性好。但是很多事情都是两面性的。就像现在习惯了vs的方便，当面临linux C++的WebService调用时，博主直接就懵逼了。闲话少说，进入正题。 最初的尝试 qtsoap 由于是QT项目，一向懒惰的博主首先想到的是去找QT下的开源方案。几番查找，找到了这个4、5年前的开源项目qtsoap。 通过官方示例和各种查阅文档。最终博主终于完成一个调用类，结构如下： 1234567891011121314151617181920212223242526272829303132333435#ifndef WEBSERVICE_H#define WEBSERVICE_H#include &lt;qtsoap.h&gt;class WebService:public QObject&#123; Q_OBJECTpublic: /********************************************** * description: Constructor * parameter: serviceUrl webservice url * opration request method * ********************************************/ WebService(QString serviceUrl,QString operation); ~WebService(); /************************************* * description: Submit Request * parameter: argument for operation * ***********************************/ void SubmitRequest(QString argument);private slots: /*********************************************** * description: Response after operation * parameter: responseMessage * *********************************************/ void getResponse(const QtSoapMessage &amp;response);private: //服务地址 QString serviceUrl; //执行的操作名称 QString operation; QtSoapHttpTransport http;&#125;; 只有两个函数：提交请求和获得响应，博主高高兴兴的编译 运行， 又是一脸懵，无论怎么检查，响应永远是Network transport error。没办法开始翻源码。当我看到要翻3000+行C++代码时，我的内心是拒绝的。 无奈之下改翻头文件，XMLschema和namespace深深的吸引了我 这地址1998和1999，主观上以我对自己的了解，我是不会再改这货了。最后还是去QT开源社区的群咨询了一下下。许久只得到了以下回复其余都是乱扯： 1qtsoap,我已经放弃了。 最后还是默默的关掉了项目，寻求其他方案。 进一步了解WebService和QNetworkAccessManager 无奈之下只能进一步开始了解WebService。什么是WebService呢？简单的说就是一种可以接受和相应网络上其他系统传递的请求，轻量的通讯技术，通过soap协议在web上提供服务。这里就不做详细解释了，想了解的同学可以自行搜索或参阅文末链接。基于对WebService的进一步了解，也就是说我们只需要通过网络向WebService发送soap消息请求就可以了。于是下一步就是解决QT下的网络通信了。于是主角QNetworkAccessManager登场。在了解了如何使用QNetworkAccessManager发送post和get请求后懒癌晚期的还是选择了寻找现成的方法。最后找到了这个：QNetworkAccessManager调用WebService 因为目标WebService需要客户端传递xml格式的字符串，博主在以上方案上修改了部分代码又加了两个函数。源码奉上： 头文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** ***************************************************** * QWebService * * 通过http post或get请求调用WebService * * ******************************************************/#ifndef QWEBSERVICE_H#define QWEBSERVICE_H#include &lt;QTimer&gt;#include &lt;QThread&gt;#include &lt;QNetworkAccessManager&gt;#include &lt;QNetworkRequest&gt;#include &lt;QNetworkReply&gt;/** * xml字符串，转义符替换。 **/void Xml2Esc(QString &amp;xmlString);void Esc2Xml(QString &amp;escString);class NetDataListenerThread:public QThread&#123; Q_OBJECTpublic: NetDataListenerThread(QNetworkAccessManager *manager,QNetworkReply * reply,int timeoutms,QObject *parent = 0); ~NetDataListenerThread(); QByteArray getBa() const; bool getIsWaitTimeOut() const;protected: virtual void run();private: bool waitForConnect();protected slots: void slot_waitTimeout();signals: void sig_waitTimeout();private: QNetworkAccessManager *mManager; int m_TimeOutms; bool m_waitTimeOut; bool m_isWaitTimeOut; QNetworkReply * m_reply;&#125;;/** * @brief The WebServiceHelp class webservice调用帮助类 * @author zp */class WebServiceHelp:public QObject&#123; Q_OBJECTprivate: QString postXml = &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;utf-8\\&quot;?&gt;&lt;soap:Envelope xmlns:xsi=\\&quot;http://www.w3.org/2001/XMLSchema-instance\\&quot; xmlns:xsd=\\&quot;http://www.w3.org/2001/XMLSchema\\&quot; xmlns:soap=\\&quot;http://schemas.xmlsoap.org/soap/envelope/\\&quot;&gt;&lt;soap:Body&gt;&lt;toTraditionalChinese xmlns=\\&quot;http://webxml.com.cn/\\&quot;&gt;&lt;sText&gt;ARGUMENT&lt;/sText&gt;&lt;/toTraditionalChinese&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;&quot;; class Dispose &#123; public: ~Dispose(); &#125;;public: static WebServiceHelp * getInstance();public: /** * @brief sendGetRequest 发送Get请求 * @param urlStr url * @param ba 返回数据 * @param timeOutms 超时时间 * @return 返回错误代码 */ QNetworkReply::NetworkError sendGetRequest(QString urlStr, QByteArray &amp; ba, int timeOutms=3000); /** * @brief sendPostRequest 发送post请求 * @param website 网址 * @param methodName 方法名称 * @param param 参数 * @param postBa post数据 * @param code 返回代码 * @param message 返回信息 * @param data 返回数据 * @param timeOutms 超时时间 * @return 返回错误代码 */ QNetworkReply::NetworkError sendPostRequest(QString website,const QString argument, QByteArray&amp; retBa, int timeOutms=3000);protected slots: void slot_error(QNetworkReply::NetworkError code);private: static WebServiceHelp * serverHelp; static WebServiceHelp::Dispose disp; QNetworkAccessManager *manager; QNetworkReply::NetworkError m_errCode;private: WebServiceHelp(QObject *parent=0); ~WebServiceHelp();&#125;;#endif // QWEBSERVICE_H 类文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172 #include &quot;qwebservice.h&quot;#include &lt;QEventLoop&gt;NetDataListenerThread::NetDataListenerThread(QNetworkAccessManager *manager, QNetworkReply *reply, int timeoutms, QObject *parent) :QThread(parent),mManager(manager),m_TimeOutms(timeoutms),m_reply(reply)&#123; m_waitTimeOut = false; m_isWaitTimeOut = false;&#125;NetDataListenerThread::~NetDataListenerThread()&#123;&#125;void NetDataListenerThread::run()&#123; m_isWaitTimeOut = waitForConnect();&#125;bool NetDataListenerThread::waitForConnect()&#123; QEventLoop eventLoop; QTimer * timer = NULL; m_waitTimeOut = false; bool bWaitTimeOut = false; if (m_TimeOutms &gt; 0) &#123; timer = new QTimer; connect(timer, SIGNAL(timeout()), this, SLOT(slot_waitTimeout())); timer-&gt;setSingleShot(true); timer-&gt;start(m_TimeOutms); connect(this, SIGNAL(sig_waitTimeout()), &amp;eventLoop, SLOT(quit())); &#125; connect(mManager, SIGNAL(finished(QNetworkReply *)), &amp;eventLoop, SLOT(quit())); if (m_reply != NULL) &#123; connect(m_reply, SIGNAL(readyRead()), &amp;eventLoop, SLOT(quit())); &#125; eventLoop.exec(); if (timer != NULL) &#123; timer-&gt;stop(); delete timer; timer = NULL; &#125; bWaitTimeOut = m_waitTimeOut; m_waitTimeOut = false; return !bWaitTimeOut;&#125;void NetDataListenerThread::slot_waitTimeout()&#123; m_waitTimeOut = true; emit sig_waitTimeout();&#125;bool NetDataListenerThread::getIsWaitTimeOut() const&#123; return m_isWaitTimeOut;&#125;WebServiceHelp * WebServiceHelp::serverHelp = NULL;WebServiceHelp::Dispose WebServiceHelp::disp;WebServiceHelp::WebServiceHelp(QObject *parent):QObject(parent)&#123; manager = new QNetworkAccessManager(); m_errCode= QNetworkReply::NoError;&#125;WebServiceHelp::~WebServiceHelp()&#123; manager-&gt;deleteLater();&#125;WebServiceHelp *WebServiceHelp::getInstance()&#123; if(serverHelp==NULL) &#123; serverHelp = new WebServiceHelp(); &#125; return serverHelp;&#125;QNetworkReply::NetworkError WebServiceHelp::sendGetRequest(QString urlStr, QByteArray &amp; ba,int timeOutms)&#123; QNetworkReply::NetworkError retError = QNetworkReply::NoError; m_errCode= QNetworkReply::NoError; QNetworkRequest request; QUrl url(urlStr); request.setUrl(url); QNetworkReply *reply = manager-&gt;get(request); connect(reply,static_cast&lt;void (QNetworkReply::*)(QNetworkReply::NetworkError)&gt;(&amp;QNetworkReply::error),this,&amp;WebServiceHelp::slot_error); QEventLoop eventLoop; NetDataListenerThread * thread = new NetDataListenerThread(manager,reply,timeOutms); connect(thread, &amp;NetDataListenerThread::finished,&amp;eventLoop,&amp;QEventLoop::quit); thread-&gt;start(); eventLoop.exec(); if(thread-&gt;getIsWaitTimeOut()) &#123; ba = reply-&gt;readAll(); &#125; else &#123; m_errCode=QNetworkReply::TimeoutError; &#125; thread-&gt;deleteLater(); delete reply; delete thread; thread = NULL; retError = m_errCode; m_errCode= QNetworkReply::NoError; return retError;&#125;QNetworkReply::NetworkError WebServiceHelp:: sendPostRequest(QString website, const QString argument, QByteArray &amp;retBa, int timeOutms)&#123; QString urlStr =website; QByteArray postBa=postXml.replace(&quot;ARGUMENT&quot;,argument).toUtf8(); qDebug()&lt;&lt;postBa; QNetworkReply::NetworkError retError = QNetworkReply::NoError; m_errCode= QNetworkReply::NoError; QNetworkRequest request; QSslConfiguration config; config.setPeerVerifyMode(QSslSocket::VerifyNone); config.setProtocol(QSsl::TlsV1SslV3); request.setSslConfiguration(config); QUrl url(urlStr); request.setUrl(url); request.setHeader(QNetworkRequest::ContentTypeHeader,&quot;text/xml; charset=utf-8&quot;); request.setHeader(QNetworkRequest::ContentLengthHeader,postBa.length()); QNetworkReply *reply = manager-&gt;post(request,postBa); connect(reply,static_cast&lt;void (QNetworkReply::*)(QNetworkReply::NetworkError)&gt;(&amp;QNetworkReply::error),this,&amp;WebServiceHelp::slot_error); QEventLoop eventLoop; NetDataListenerThread * thread = new NetDataListenerThread(manager,reply,timeOutms); connect(thread, &amp;NetDataListenerThread::finished,&amp;eventLoop,&amp;QEventLoop::quit); thread-&gt;start(); eventLoop.exec(); if(thread-&gt;getIsWaitTimeOut()) &#123; retBa = reply-&gt;readAll(); &#125; else &#123; m_errCode=QNetworkReply::TimeoutError; &#125; thread-&gt;deleteLater(); delete reply; delete thread; thread = NULL; retError = m_errCode; m_errCode= QNetworkReply::NoError; return retError;&#125;void WebServiceHelp::slot_error(QNetworkReply::NetworkError code)&#123; m_errCode = code;&#125;WebServiceHelp::Dispose::~Dispose()&#123; if(WebServiceHelp::serverHelp!=NULL) &#123; delete WebServiceHelp::serverHelp; WebServiceHelp::serverHelp=NULL; &#125;&#125;void Xml2Esc(QString &amp;xmlString)&#123; xmlString.replace(&quot;&lt;&quot;,&quot;&amp;lt;&quot;); xmlString.replace(&quot;&gt;&quot;,&quot;&amp;gt;&quot;); xmlString.replace(&quot;&amp;&quot;,&quot;&amp;amp;&quot;); xmlString.replace(&quot;&apos;&quot;,&quot;&amp;apos;&quot;); xmlString.replace(&quot;\\&quot;&quot;,&quot;&amp;quot;&quot;);&#125;void Esc2Xml(QString &amp;escString)&#123; escString.replace(&quot;&amp;lt;&quot;,&quot;&lt;&quot;); escString.replace(&quot;&amp;gt;&quot;,&quot;&gt;&quot;); escString.replace(&quot;&amp;amp;&quot;,&quot;&amp;&quot;); escString.replace(&quot;&amp;apos;&quot;,&quot;&apos;&quot;); escString.replace(&quot;&amp;quot;&quot;,&quot;\\&quot;&quot;);&#125; 这样我们只需在项目加入以上代码，直接调用函数发送请求就ok了 1QNetworkReply::NetworkError ret=WebServiceHelp::getInstance()-&gt;sendPostRequest(url,argement,retba); 最终的选择 gsoap 虽然博主已经通过发送post请求实现了WebService的调用，但开会时平台方还是建议用gsoap实现WebService服务或调用WebService。最终博主还是默默的将gsoap下载下来。默默的查了查C++的调用方法。然后默默的将项目替换成使用gsoap调用WebService。 关于gsoap的C++使用方法博主会有单独的文章介绍。今天就先写到这里，出差在宾馆写这些已经很佩服我自己了。继续加油吧。。。 附链 qtsoap WebService工作原理 QNetworkAccessManager gsoap","categories":[{"name":"QT","slug":"QT","permalink":"http://yxqblog.tk/categories/QT/"}],"tags":[{"name":"QT","slug":"QT","permalink":"http://yxqblog.tk/tags/QT/"},{"name":"C++","slug":"C","permalink":"http://yxqblog.tk/tags/C/"},{"name":"qtsoap","slug":"qtsoap","permalink":"http://yxqblog.tk/tags/qtsoap/"},{"name":"gsoap","slug":"gsoap","permalink":"http://yxqblog.tk/tags/gsoap/"},{"name":"WebService","slug":"WebService","permalink":"http://yxqblog.tk/tags/WebService/"}]},{"title":"ArcMap面要素处理之平滑面(Smooth Polygon)","slug":"ArcMap-Ploygon-Smooth","date":"2017-06-14T16:00:00.000Z","updated":"2018-03-25T09:21:53.067Z","comments":true,"path":"2017/06/15/ArcMap-Ploygon-Smooth/","link":"","permalink":"http://yxqblog.tk/2017/06/15/ArcMap-Ploygon-Smooth/","excerpt":"","text":"摘要创建一个新的输出要素类，包含从输入面上删除某些指定大小的部分或孔洞所得的要素。 插图 用法 有两种平滑方法可供选择： PAEK（指数核的多项式近似）方法可根据平滑容差对面进行平滑处理。每个面经过平滑处理后，其折点都可能比之前多。平滑容差参数可控制计算新折点时用到的“移动”路径的长度。长度越短，保留的细节越多，处理时间也越长。 贝塞尔插值方法（Python 中为 BEZIER_INTERPOLATION）对面进行平滑处理时无需使用容差，而是通过创建贝塞尔曲线来匹配输入线。如果输出为 shapefile，则将创建近似的贝塞尔曲线，因为真正的贝塞尔曲线无法存储在 shapefile 中。 平滑处理可能带来拓扑错误，如面轮廓的交叉。使用处理拓扑错误参数中的标记错误选项（Python 中为 FLAG_ERRORS）可识别这些错误。将添加两个字段 InPoly_FID 和 SmoPlyFlag 以包含输入要素 ID 和拓扑错误。SmoPlyFlag 字段中的值为 1 表明存在拓扑错误；0（零）表明不存在错误。InPoly_FID 字段将输出面连接到其输入面。标记错误选项不能在编辑会话中使用。 在平滑处理的过程中，可能创建无效（自相交）的几何，并将对无效的几何进行修复，但不会将其改进。例如，如果一个面自交叉，则这个面将成为多部分面，但显示效果依然是自交叉。 语法1SmoothPolygon_cartography (in_features, out_feature_class, algorithm, tolerance, &#123;endpoint_option&#125;, &#123;error_option&#125;) 参数 说明 数据类型 in_features 要平滑处理的面要素。 Feature Layer out_feature_class 要创建的输出面要素类。 Feature Class algorithm 指定平滑算法。PAEK —Polynomial Approximation with Exponential Kernel（指数核的多项式近似）的首字母缩略词。该方法可以计算不经过输入面折点的平滑面。这是默认设置。BEZIER_INTERPOLATION —拟合折点间的贝塞尔曲线。生成的面将经过输入面的折点。该算法不需要容差。在 shapefile 输出中，将创建近似的贝塞尔曲线。 String tolerance 设置 PAEK 算法使用的容差。必须指定一个容差，且值必须大于零。可以指定首选单位；默认为要素单位。使用 BEZIER_INTERPOLATION 平滑算法时，必须输入 0 作为占位符。 Linear Unit endpoint_option(可选) 指定是否保留孤立面环的端点。该选项仅适用于 PAEK 算法。FIXED_ENDPOINT —保留孤立面环的端点。这是默认设置。NO_FIXED —通过孤立面环的端点进行平滑处理。 Boolean error_option(可选) 指定如何处理拓扑错误（可能是在该过程中引发的，如线的交叉或重叠）。NO_CHECK —指定不检查拓扑错误。这是默认设置。FLAG_ERRORS —指定标记拓扑错误（如果发现拓扑错误）。 String 代码实例平滑面示例（Python 窗口）以下 Python 窗口脚本演示了如何在即时模式下使用“平滑面”工具。 1234import arcpyimport arcpy.cartography as CAarcpy.env.workspace = &quot;C:/data&quot;CA.SmoothPolygon(&quot;soils.shp&quot;, &quot;C:/output/output.gdb/smoothed_soils&quot;, &quot;PAEK&quot;, 100) 平滑面示例 2（独立脚本）以下独立 Python 脚本演示了如何使用“简化面”工具。 123456789101112131415161718192021222324# Name: SmoothPolygon_Example2.py# Description: Eliminate small islands before simplifying and smoothing lake boundaries # Import system modulesimport arcpyimport arcpy.cartography as CAimport arcpy.management as DM # Set environment settingsarcpy.env.workspace = &quot;C:/data/Portland.gdb/Hydrography&quot; # Set local variablesinLakeFeatures = &quot;lakes&quot;eliminatedFeatures = &quot;C:/data/PortlandOutput.gdb/lakes_eliminated&quot;simplifiedFeatures = &quot;C:/data/PortlandOutput.gdb/lakes_simplified&quot;smoothedFeatures = &quot;C:/data/PortlandOutput.gdb/lakes_smoothed&quot;# Eliminate small islands in lake polygons.DM.EliminatePolygonPart(inLakeFeatures, eliminatedFeatures, 100, &quot;OR&quot;, 0, &quot;CONTAINED_ONLY&quot;) # Simplify lake polygons.CA.SimplifyPolygon(eliminatedFeatures, simplifiedFeatures, &quot;POINT_REMOVE&quot;, 50, 200, &quot;RESOLVE_ERRORS&quot;, &quot;KEEP_COLLAPSED_POINTS&quot;, &quot;CHECK&quot;) # Smooth lake polygons.CA.SmoothPolygon(simplifiedFeatures, smoothedFeatures, &quot;PAEK&quot;, 100, &quot;&quot;, &quot;FLAG_ERRORS&quot;) 了解更多要了解更多关于ArcMap的知识请参阅以下链接： desktop.arcgis.com","categories":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/categories/ArcMap/"}],"tags":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/tags/ArcMap/"},{"name":"Polygon","slug":"Polygon","permalink":"http://yxqblog.tk/tags/Polygon/"},{"name":"Gp","slug":"Gp","permalink":"http://yxqblog.tk/tags/Gp/"}]},{"title":"使用MVVM模式开发Arcgis Runtime 程序","slug":"use-mvvm-in-ArcgisRuntime-app","date":"2017-05-25T16:00:00.000Z","updated":"2018-03-25T07:16:42.876Z","comments":true,"path":"2017/05/26/use-mvvm-in-ArcgisRuntime-app/","link":"","permalink":"http://yxqblog.tk/2017/05/26/use-mvvm-in-ArcgisRuntime-app/","excerpt":"","text":"MVVM介绍MVVM是XAML程序开发中常用的设计模式，能够实现用户界面和数据、业务逻辑的完全分离。为实现分离MVVM将程序分割为以下三个类别。 Model - 程序中使用的数据模型。 View - 用户界面。 ViewModel-处理Model中的数据并为View提供业务逻辑。 理想的MVVM程序中，组件必须完全包含在这三个类别中。比如XAML页面中不应包含代码，同样所有与视图不直接相关的代码都必须由ViewModel提供。数据绑定提供了支持在WPF中，Windows商店和Windows Phone应用程序允许使用XAML定义UI和将控件与视图ViewModel类所需的数据和功能绑定。 一般来说，使用MVVM创建程序时，我们的大部分时间都花在ViewModel上。这些类提供提供界面使用的数据。ViewModel也可能包含处理用户界面事件和其他View需要的业务逻辑。 MVVM模式文档很完备。该教程不是为讲述MVVM模式，而是介绍在其ArcGisRun Runtime SDK for .NET开发中的使用。要了解更多关于MVVM的内容，请参阅文末链接。 先决条件该教程需要Microsoft Visual Studio和 ArcGIS Runtime SDK for .NET.SDK安装和系统需求请参阅以下链接installing the SDK and system requirements. 需要了解 Visual Studio, XAML, and C# 。 创建WPF程序使用Visual Studio创建一个WPF程序。 打开Visual Studio。 选择文件&gt;新建&gt;项目创建一个新的项目。 在新建项目界面选择Windows Desktop &gt; WPF 程序 提示：ArcGIS Runtime SDK for .NET 提供了项目模板：ArcGIS Runtime 10.2.7 for .NET App使用模板创建项目会自动添加引用和带有mapvew的主页面。 选择项目路径修改项目名称为MvvmApp。 点击确定创建项目。 右击项目下的引用添加Esri.ArcGISRuntime引用。 Esri.ArcGISRuntime.dll包含mapcontrol和要用到的所有核心API。 添加Map本程序将加载ArcGIS Online 的影像底图和一个点图层。定义点的渲染方式和当前的视图范围。 在XAML designer中使用ArcGISRuntime需要添加命名空间。 在设计器中打开主页面MainWindow.xaml. 添加以下命名空间 1xmlns:esri=&quot;http://schemas.esri.com/arcgis/runtime/2013&quot; 在标签下添加以下xaml代码 12345678910111213141516171819&lt;esri:MapView x:Name=&quot;MyMapView&quot;&gt; &lt;esri:Map&gt; &lt;esri:Map.InitialViewpoint&gt; &lt;esri:ViewpointExtent XMin=&quot;-1631122.453&quot; YMin=&quot;4253523.549&quot; XMax=&quot;4163264.136&quot; YMax=&quot;8976345.495&quot; /&gt; &lt;/esri:Map.InitialViewpoint&gt; &lt;esri:ArcGISTiledMapServiceLayer ID=&quot;BaseMap&quot; ServiceUri=&quot;http://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer&quot;/&gt; &lt;esri:FeatureLayer ID=&quot;Incidents&quot;&gt; &lt;esri:ServiceFeatureTable ServiceUri=&quot;http://sampleserver6.arcgisonline.com/arcgis/rest/services/SF311/FeatureServer/0&quot;/&gt; &lt;esri:FeatureLayer.Renderer&gt; &lt;esri:SimpleRenderer&gt; &lt;esri:SimpleMarkerSymbol Color=&quot;Red&quot; Size=&quot;16&quot; Style=&quot;Triangle&quot;/&gt; &lt;/esri:SimpleRenderer&gt; &lt;/esri:FeatureLayer.Renderer&gt; &lt;/esri:FeatureLayer&gt; &lt;esri:GraphicsLayer ID=&quot;PointGraphics&quot;/&gt; &lt;/esri:Map&gt;&lt;/esri:MapView&gt; 编译运行界面如下图。 移除地图数据为了将界面与数据和逻辑分离，我们移除mapview中的map。将其存储在程序的资源字典中，并使用数据绑定显示到界面。 选择esri:MapView标签下的所有内容》剪切。 打开App.xaml文件。 将剪切的代码粘贴到&lt;Application.Resources&gt;标签下。 12345678910111213141516171819202122&lt;Application.Resources&gt; &lt;esri:Map&gt; &lt;esri:Map.InitialViewpoint&gt; &lt;esri:ViewpointExtent XMin=&quot;-1631122.453&quot; YMin=&quot;4253523.549&quot; XMax=&quot;4163264.136&quot; YMax=&quot;8976345.495&quot; /&gt; &lt;/esri:Map.InitialViewpoint&gt; &lt;esri:ArcGISTiledMapServiceLayer ID=&quot;BaseMap&quot; ServiceUri=&quot;http://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer&quot;/&gt; &lt;esri:FeatureLayer ID=&quot;Incidents&quot;&gt; &lt;esri:ServiceFeatureTable ServiceUri=&quot;http://sampleserver6.arcgisonline.com/arcgis/rest/services/SF311/FeatureServer/0&quot;/&gt; &lt;esri:FeatureLayer.Renderer&gt; &lt;esri:SimpleRenderer&gt; &lt;esri:SimpleMarkerSymbol Color=&quot;Red&quot; Size=&quot;16&quot; Style=&quot;Triangle&quot;/&gt; &lt;/esri:SimpleRenderer&gt; &lt;/esri:FeatureLayer.Renderer&gt; &lt;/esri:FeatureLayer&gt; &lt;esri:GraphicsLayer ID=&quot;PointGraphics&quot;/&gt; &lt;/esri:Map&gt;&lt;/Application.Resources&gt; 添加ArcgisRuntime命名空间。 给map添加x:Key属性并赋值IncidentMap。 1&lt;esri:Map x:Key=&quot;IncidentMap&quot;&gt; x:Key 用与识别资源，作用范围内值应唯一 返回主页面添加代码将IncidentMap资源绑定到mapview 12&lt;esri:MapView x:Name=&quot;MyMapView&quot; Map=&quot;&#123;Binding Source=&#123;StaticResource IncidentMap&#125;&#125;&quot;&gt; &lt;/esri:MapView&gt; 地图属性的数据绑定使用绑定标记扩展在XAML中指定。可以绑定应用程序中的资源，页面上的其他元素，或应用程序中提供数据的类。在XAML应用程序中对数据绑定的更多信息可以参阅数据绑定概述（MSDN）.aspx)。 编译运行，程序与之前相同。 我们的程序现在实现MVVM模式了吗？还不是最理想的形式，app.xaml页面作为一个视图模型提供了一个可以绑定的地图。这说明使用该模式的优势之一，它清楚地将UI与实现细节分开。MapView是UI控件，属于页面。它包含的地图和图层是控件中显示的数据，该数据需要更改，并且应在UI之外进行管理。有了这个架构，页面和地图是松散耦合的，这意味着你可以很容易地改变一个不影响另一个。若要更改页中显示的地图，只需将绑定指向应用程序中可用的其他资源。 为实现传统形式的MVVM模式，我们需要创建一个ViewModel类来充当页面的数据上下文，并公开用户界面可以绑定的数据和功能。 创建一个ViewModel类ViewModel提供视图可以通过数据绑定访问的数据和功能。一个视图对应一个视图模型是很常见的，但是多个些视图模型与单个视图关联并不多见。我们也可以有一个视图模型，该模型被应用程序中的几个不同视图使用。我们将创建一个单一的视图模型（mapviewmodel）提供的所有页面需要的数据和功能。 右击项目》添加类：MapViewModel.cs. 添加引用 12using Esri.ArcGISRuntime.Controls;using Esri.ArcGISRuntime.Layers; 添加新的属性：IncidentMap。 123456private Map map;public Map IncidentMap&#123; get &#123; return this.map; &#125; set &#123; this.map = value; &#125;&#125; IncidentMap属性提供视图需要绑定的数据。 添加构造函数、初始化地图 12345public MapViewModel()&#123; // when the view model initializes, read the map from the App.xaml resources this.map = App.Current.Resources[&quot;IncidentMap&quot;] as Map;&#125; 绑定ViewModel到View为了关联ViewModel和View，我们需要将View的DataContext属性设置为ViewModel的一个实例。可以使用xaml或view的codebehind设置。以下步骤使用xaml将viewmodel中的incidentmap绑定到view中mapview的map属性 打开app.xaml。添加本地程序集xaml命名空间 123456&lt;Application x:Class=&quot;MvvmApp.App&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:esri=&quot;http://schemas.esri.com/arcgis/runtime/2013&quot; xmlns:local=&quot;clr-namespace:MvvmApp&quot; StartupUri=&quot;MainWindow.xaml&quot;&gt; 在Application.Resources 标签IncidentMap定义后添加xanl定义一个MapViewModel对象并赋值X:key为MapVM 1&lt;local:MapViewModel x:Key=&quot;MapVM&quot;/&gt; 打开MainWindow.xaml 设置整个页面的DataContext绑定MapVM对象。 123456&lt;Window x:Class=&quot;MvvmApp.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:esri=&quot;http://schemas.esri.com/arcgis/runtime/2013&quot; Title=&quot;MainWindow&quot; Height=&quot;350&quot; Width=&quot;525&quot; DataContext=&quot;&#123;Binding Source=&#123;StaticResource MapVM&#125;&#125;&quot;&gt; 一旦ViewModel设置为整个页面的DataContext，页面上的任一控件都可绑定ViewModel暴露出的属性。 修改mapview的绑定声明。 12&lt;esri:MapView x:Name=&quot;MyMapView&quot; Map=&quot;&#123;Binding IncidentMap&#125;&quot;&gt; &lt;/esri:MapView&gt; 编译运行，地图和在页面中直接定义时相同。 使用这种模式显示地图的优势是什么？无论我们在哪里定义地图，应用程序看起来都是一样的，但使用ViewModel似乎增加了很多复杂性。对于这样一个简单的应用程序，使用MVVM模式的确没有优势。但当应用程序变得更加复杂时，你会发现MVVM架构使应用程序更容易维护并促进应用程序之间共享代码。 在ViewModel中处理点击事件在视图模型中保存数据并将其绑定到UI很简单，但是关于视图函数和功能呢？ 如果完全实现MVVM模式，所有的业务逻辑都应包含在ViewModel中。页面的codebehind也不应包含事件代码。幸运的是，数据绑定还可以将View中的控件事件绑定到ViewModel中的代码。 执行Command一些控件，如按钮、复选框、单选按钮和菜单项，提供了一个Command属性。Command是自定义类，实现ICommand接口。定义当一个控件点击时的事件（执行方法），并确定何时应该启用（执行方法）。可以在视图模型中创建Command，并绑定到相应控件的Command属性。 提示：现在有很多MVVM的框架提供了ICommand的实现。使用这些框架时，我们可以在视图模型中实例化命令对象，而不必创建本节所描述的自己的命令类的中间步骤。如果计划广泛使用MVVM，可以考虑使用框架开发应用程序，如MVVMLight。 新建类并命名DelegateCommand.cs。 添加命名空间System.Windows.Input 1using System.Windows.Input; 在 DelegateCommand类中实现Icommand接口。完整的实现代码如下： 1234567891011121314151617181920212223242526272829303132class DelegateCommand : System.Windows.Input.ICommand&#123; // a var to store the command&apos;s execute logic (button click, for example) private readonly Action&lt;object&gt; execute; // a var to store the command&apos;s logic for enabling/disabling private readonly Func&lt;object, bool&gt; canExecute; // an event for when the value of &quot;CanExecute&quot; changes (not implemented) public event EventHandler CanExecuteChanged; // constructor: store the logic for executing and enabling the command public DelegateCommand(Action&lt;object&gt; executeAction, Func&lt;object, bool&gt; canExecuteFunc = null) &#123; this.canExecute = canExecuteFunc; this.execute = executeAction; &#125; // if it was passed in, execute the enabling logic for the command public bool CanExecute(object parameter) &#123; if (this.canExecute == null) &#123; return true; &#125; return this.canExecute(parameter); &#125; // execute the command logic public void Execute(object parameter) &#123; this.execute(parameter); &#125;&#125; 当需要绑定一个按钮和命令时，创建一个delegatecommand实例传递事件命令的执行和控件到构造函数。执行操作的参数是object类型，以给命令提供最大的灵活性。 保存和关闭DelegateCommand.cs。 在ViewModel中创建Command属性任何需要绑定的内容都必须是public的属性。下一步我们将创建MapViewModel的一个新属性返回一个DelegateCommand 对象。该命令被定义为执行和启用逻辑，因此它可以绑定到视图中的按钮。 打开MapViewModel类定义一个public属性：ToggleLayerCommand 返回一个DelegateCommand对象。 1public DelegateCommand ToggleLayerCommand &#123; get; set; &#125; 创建一个新的函数响应命令执行，命名togglelayer。该函数控制map中图层的可见性。输入参数指定要修改的图层名称。 123456private void ToggleLayer(object parameter)&#123; var lyr = this.map.Layers[parameter.ToString()]; lyr.IsVisible = !(lyr.IsVisible); &#125; 创建另一个新的函数来确定Command的执行状态。由于命令修改一个特定的图层，只有当图层存在时才可执行。参数与上一个函数相同。 12345private bool OkToExecute(object parameter)&#123; var lyr = this.map.Layers[parameter.ToString()] as FeatureLayer; return (lyr != null);&#125; 如果指定名称的图层不存在，oktoexecute返回false，禁用相关的控件。 在mapviewmodel的构造函数，添加以下代码行来实例化togglelayercommand。传递thetogglelayer函数作为命令的执行逻辑、oktoexecute为enable逻辑。 123456public MapViewModel()&#123; // when the view model initializes, read the map from the App.xaml resources this.map = MvvmApp.App.Current.Resources[&quot;IncidentMap&quot;] as Map; ToggleLayerCommand = new DelegateCommand(ToggleLayer, OkToExecute);&#125; ##绑定一个button到ViewModel的Command 按钮提供一个可执行代码的单击事件。指定一个Command定义按钮单击的代码，它的优点是还包含了指示按钮何时启用或禁用的逻辑。一个按钮对象的Command属性都可以绑定到实现ICommand接口的对象。 在MainWindow.xaml 页面添加一个新的button 123&lt;Button Height=&quot;30&quot; Width=&quot;70&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Bottom&quot; Content=&quot;Toggle&quot; /&gt; 设置button的Command属性绑定到view model的ToggleLayerCommand属性。 1234&lt;Button Height=&quot;30&quot; Width=&quot;70&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Bottom&quot; Content=&quot;Toggle&quot; Command=&quot;&#123;Binding ToggleLayerCommand&#125;&quot;/&gt; 设置按钮的commandparameter属性值，为Command提供参数。 12345&lt;Button Height=&quot;30&quot; Width=&quot;70&quot; HorizontalAlignment=&quot;Left&quot; VerticalAlignment=&quot;Bottom&quot; Content=&quot;Toggle&quot; Command=&quot;&#123;Binding ToggleLayerCommand&#125;&quot; CommandParameter=&quot;Incidents&quot;/&gt; 编译运行，点击Toggle按钮控制incidents图层的可见性。 在ViewModel中处理其他事件前面描述的视图模型中绑定命令的过程适用于提供所需命令属性的控件。如果需要处理其他不能直接使用命令属性绑定的事件，该怎么办？幸运的是，.NET提供了额外的类，可以将视图中的事件绑定到视图模型中的命令或函数。 在下面的步骤中，将使用system.windows.interactivity的类来处理MapView的ExtentChanged事件。 选择**项目》添加引用，添加System.Windows.Interactivity引用 提示：如果引用不存在需要安装Microsoft Expression Blend SDK.或在NuGet中搜索“blend”下载。 打开MainWindow.xaml在标签内添加以下xaml命名空间。 1xmlns:interactivity=&quot;http://schemas.microsoft.com/expression/2010/interactivity&quot; MapView 标签下添加以下xaml定义ExtentChanged事件的触发器。 1234567&lt;esri:MapView x:Name=&quot;MyMapView&quot; Map=&quot;&#123;Binding IncidentMap&#125;&quot;&gt; &lt;interactivity:Interaction.Triggers&gt; &lt;interactivity:EventTrigger EventName=&quot;ExtentChanged&quot;&gt; &lt;/interactivity:EventTrigger&gt; &lt;/interactivity:Interaction.Triggers&gt;&lt;/esri:MapView&gt; 可以使用一个函数（方法）或一个命令对象来响应事件。因为需要一个参数（MapView），所以使用command并提供一个CommandParameter将当前视图范围传递到view model 添加以下xaml定义InvokeCommandAction响应事件。ViewModel中还不存在ExtentChangedCommand，我们稍后创建。 123&lt;interactivity:InvokeCommandAction Command=&quot;&#123;Binding ExtentChangedCommand&#125;&quot; CommandParameter=&quot;&#123;Binding ElementName=MyMapView&#125;&quot;/&gt; 打开MapViewModel.cs添加以下代码定义一个DelegateCommand对象并命名为ExtentChangedCommand 1public DelegateCommand ExtentChangedCommand &#123; get; set; &#125; 添加以下函数响应视图范围改变。现在需要确保能获取到 mapview的视图范围。 123456public void MyMapViewExtentChanged(object parameter)&#123; var mv = parameter as MapView; var extent = mv.Extent;&#125; 在构造函数中添加以下代码实例化ExtentChangedCommand. 1234567public MapViewModel()&#123; // when the view model initializes, read the map from the App.xaml resources this.map = MvvmApp.App.Current.Resources[&quot;IncidentMap&quot;] as Map; ToggleLayerCommand = new DelegateCommand(ToggleLayer, OkToExecute); ExtentChangedCommand = new DelegateCommand(MyMapViewExtentChanged);&#125; DelegateCommand中的是否可执行逻辑是可选的，所以我们没有指定它。 在MyMapViewExtentChanged函数最后一行添加断点，运行程序，看是否命中断点查看获取的mapview范围。测试完毕后移除断点。 至此我们已经完成了在ViewModel中处理视图范围更改事件的绑定。以上过程可以用来处理所有界面控件的事件，包括不提供Command属性的控件。 绑定视图的范围值要在应用程序中显示当前范围的坐标，需要在ViewModel上创建新公共属性以公开该信息。然后可以将属性绑定到用户界面元素，如文本框。 打开MapViewModel.cs添加以下代码定义一个CurrentExtentString属性。 123456789101112private string extentString;public string CurrentExtentString &#123; get &#123; return this.extentString; &#125; set &#123; this.extentString = value; &#125; &#125; 在MyMapViewExtentChanged中添加以下代码设置CurrentExtentString的值 1234567public void MyMapViewExtentChanged(object parameter)&#123; var mv = parameter as MapView; var extent = mv.Extent; CurrentExtentString = string.Format(&quot;XMin=&#123;0:F2&#125; YMin=&#123;1:F2&#125; XMax=&#123;2:F2&#125; YMax=&#123;3:F2&#125;&quot;, extent.XMin, extent.YMin, extent.XMax, extent.YMax);&#125; 视图范围描述格式如下: 1XMin=-2598746.47 YMin=4253523.55 XMax=5130888.16 YMax=8976345.50. 打开MainWindow.xaml在mapview下添加以下xaml定义一个TextBlock用来显示当前试图范围。 1234&lt;TextBlock Height=&quot;30&quot; Width=&quot;Auto&quot; FontSize=&quot;16&quot; Foreground=&quot;AliceBlue&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Bottom&quot; Text=&quot;&#123;Binding CurrentExtentString&#125;&quot;/&gt; 运行程序，发现范围描述并没有按预期显示出来。 为使数据绑定按预期工作，必须在绑定的属性梗概是触发notification事件。当前情况下在更改视图范围属性前就已经将其绑定到界面文本。当属性值更新时从未通知界面获取更新值，所以界面文本不会改变。 如果是这样的话，为什么绑定的地图工作？ViewModel的incidentmap属性设置在类的构造函数中，设置页面的数据上下文之前就已经赋值。 为了实现属性值改变的通知，我们需要实现System.ComponentModel 命名空间下的 INotifyPropertyChanged 接口。 在MapViewModel中添加以下引用。 12using System.ComponentModel;using System.Runtime.CompilerServices; 在MapViewModel中实现INotifyPropertyChanged接口 123class MapViewModel : INotifyPropertyChanged &#123; ... 添加以下代码实现PropertyChangedEventHandler 12345678public event PropertyChangedEventHandler PropertyChanged;private void RaiseNotifyPropertyChanged([CallerMemberName]string propertyName = null)&#123; if (PropertyChanged != null) &#123; PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); &#125;&#125; 在currentextentstring属性的set访问器中调用RaiseNotifyPropertyChanged函数触发notification。 12345678910111213private string extentString;public string CurrentExtentString &#123; get &#123; return this.extentString; &#125; set &#123; this.extentString = value; this.RaiseNotifyPropertyChanged(); &#125; &#125; 运行程序。当前视图范围显示在地图底部。 至此我们已完成了整个教程。如果你按此教程自己动手实现了。那么你应该对如何创建MVVM模式的ArcgisRuntime应用有了自己的理解。包括：数据绑定、Command、事件触发、属性变更通知。为了体会MVVM模式的有效性。你可以新建一个项目（也可以是其他.net平台），在不同界面下重用本例的ViewModel和Command。 本教程源码：ArcGisRuntime_MVVM_Demo 了解更多要了解更多关于MVVM的知识请参阅以下链接： Data binding overview (MSDN).aspx) MVVM pattern made simple (CodeProject) MVVM Commands (MSDN) INotifyPropertyChanged (.Net Documentation) MVVM Light toolkit (CodePlex) Caliburn.Micro framework (GitHub) 原文地址：https://developers.arcgis.com/net/10-2/desktop/guide/use-the-mvvm-design-pattern.htm","categories":[{"name":"ArcgisRuntime","slug":"ArcgisRuntime","permalink":"http://yxqblog.tk/categories/ArcgisRuntime/"}],"tags":[{"name":"MVVM","slug":"MVVM","permalink":"http://yxqblog.tk/tags/MVVM/"},{"name":"ArcgisRuntime","slug":"ArcgisRuntime","permalink":"http://yxqblog.tk/tags/ArcgisRuntime/"}]},{"title":"ArcMap面要素处理之简化面(Simplify Polygon)","slug":"ArcMap-Ploygon-Simplify","date":"2017-05-14T16:00:00.000Z","updated":"2018-03-25T09:07:17.073Z","comments":true,"path":"2017/05/15/ArcMap-Ploygon-Simplify/","link":"","permalink":"http://yxqblog.tk/2017/05/15/ArcMap-Ploygon-Simplify/","excerpt":"","text":"摘要创建一个新的输出要素类，包含从输入面上删除某些指定大小的部分或孔洞所得的要素。 插图 用法 存在两种简化方法： POINT_REMOVE 方法是两种方法中较快的。它可移除多余的折点。此方法多用于数据压缩或更为粗糙的简化，尤其适用于大家都已经了解的数据。随着容差的增大，生成的面中有棱角的部分（尖锐拐角）将显著增加，所以面要素可能变得不够美观。 BEND_SIMPLIFY 方法较慢，但通常会生成与原始几何形状更为接近的结果，因此更加美观。其操作方式为消除面要素边界上不太重要的弯曲。此方法用于少量的、更为精细的简化。 最小面积参数仅适用于简化的面。任何在简化过程完成后小于最小面积的面要素都将从输出要素类中移除。对于一组共享公共边的相邻面，该参数适用于该组面的总面积。 该工具会产生两个输出要素类，一个是存储了简化之后的面的面要素类和一个是存储了用来表示任意折叠于一点的面的那些点的点要素类。点的输出名称和位置自动从输出的面的名称获得，并以 _Pnt 作为后缀。面输出将包含所有输入字段；点输出不包含任何输入字段。 多部分 (Multipart) 面可简化为单部分。 以下为用于处理输出中的拓扑错误的 3 个选项： NO_CHECK：不检查简化过程所引入的拓扑错误。处理过程会更快。只有在可以保证数据的拓扑准确性时才使用该选项。 FLAG_ERRORS ：将对简化过程所引入的拓扑错误进行标记。当标识拓扑错误的重要性大于解决错误的重要性时，请使用此选项。编辑会话中不支持此选项。 面输出将包含两个表示要素是否存在拓扑错误的新字段。InPoly_FID 和 SimPlyFlag 分别包含输入要素 ID 和拓扑错误。 InPoly_FID 字段将折叠的点连接到其输入面。 在 SimPlyFlag 字段中，值为 1 表示引入了错误，而值为 0（零）表示未引入错误。 拓扑错误解决之后，标记值仍将保持不变。SimPlyFlag 字段用于检查包含拓扑错误的要素。 RESOLVE_ERRORS ：修复简化过程所引入的拓扑错误。处理时间将会更长。编辑会话中不支持此选项。 指定的容差可能会适合大多数面要素，但并非全部，特别是拥挤区域中的面要素。第一轮简化后如果检测到拓扑错误，则将定位涉及的边界线段（非整个面）并使用更小的容差。 此减小后的容差为减小前的百分之五十。新的容差值将用于重新简化这些线段。该迭代过程会根据需要重复多次，直到不存在拓扑错误为止。 面输出要素类包含的面数量与输入要素中包含的面数量相同，并且其使用两个新字段 MaxSimpTol 和 MinSimpTol 存储迭代过程中简化每个面时所应用的最大容差和最小容差。如果未引入错误，MaxSimpTol 和 MinSimpTol 的值将与指定的简化容差的值相同。 如果简化容差值相对较大，较大的面要素旁的较小面要素最终可能会并入较大面要素的内部。本程序无法检测到这种类型的空间关系错误。 对于 NO_CHECK 和 FLAG_ERRORS 选项，简化过程中可能会创建自相交的几何形状，并将自动修复。例如，如果面要素自身存在交叉，则经过修复，它将成为多部分面，以便各部分不存在交叉，尽管面要素的显示效果依然是自交叉。 当使用了 NO_CHECK 或 FLAG_ERRORS 时，或者选中了保留折叠点复选框时，将对点输出进行填充。如果输入面要素包含了多个部分，并且其中一个部分成为折叠的点，则表示该部分的点也将包括在点输出中。 语法1SimplifyPolygon_cartography (in_features, out_feature_class, algorithm, tolerance, &#123;minimum_area&#125;, &#123;error_option&#125;, &#123;collapsed_point_option&#125;) 参数 说明 数据类型 in_features 要简化的面要素。 Feature Layer out_feature_class 要创建的输出面要素类。 Feature Class algorithm 指定面简化算法。POINT_REMOVE —保留构成面的基本几何形状的关键点并移除所有其他点。这是默认设置。BEND_SIMPLIFY —保留面的主要几何形状并移除边界中多余的弯曲。 String tolerance 用于确定简化程度的容差。必须指定一个容差，且值必须大于零。可以选择首选单位；默认为要素单位。对于 POINT_REMOVE 算法，指定的容差表示允许的最大偏移量。对于 BEND_SIMPLIFY 算法，指定的容差表示参考弯曲基线的长度。 Linear unit minimum_area(可选) 设置要保留的简化面的最小面积。默认值为零，即保留所有面。可以为指定的值选择首选单位；默认为要素单位。 Areal unit error_option(可选) 指定处理拓扑错误的方式（这些拓扑错误可能是在处理时引入的，其中包括交叉的线、重叠的线和折叠为零长度的线）。NO_CHECK —指定不检查拓扑错误。这是默认设置。FLAG_ERRORS —指定标记拓扑错误（如果发现拓扑错误）。RESOLVE_ERRORS —指定解决拓扑错误（如果发现拓扑错误）。 String collapsed_point_option(可选) 指定是否将处理中发现的任何折叠的面积为零的面要素作为点保留下来。仅当指定了 NO_CHECK 或 FLAG_ERRORS 时，此选项才可用。KEEP_COLLAPSED_POINTS —指定将折叠的面积为零的面要素作为点保留下来。折叠面中边界的端点将存储在位于输出要素类位置的点要素类中，以输出要素类的名称加上后缀 _Pnt 作为其名称。这是默认设置。NO_KEEP —指定折叠的面积为零的面要素不作为点保留下来，即使在处理中发现也不保留；因此，点要素类将为空。 Boolean 代码实例简化面示例（Python 窗口）以下 Python 窗口脚本演示了如何在即时模式下使用“简化面”工具。 12345import arcpyfrom arcpy import envimport arcpy.cartography as CAenv.workspace = &quot;C:/data&quot;CA.SimplifyPolygon(&quot;soils.shp&quot;, &quot;C:/output/output.gdb/simplified_soils&quot;, &quot;POINT_REMOVE&quot;, 100) 简化面示例 2（独立脚本）以下独立 Python 脚本演示了如何使用“简化面”工具。 123456789101112131415161718192021222324252627# Name: SimplifyPolygon_Example2.py# Description: Eliminate small islands before simplifying and smoothing lake boundaries# Author: ESRI # Import system modulesimport arcpyfrom arcpy import envimport arcpy.management as DMimport arcpy.cartography as CA # Set environment settingsenv.workspace = &quot;C:/data/Portland.gdb/Hydrography&quot; # Set local variablesinLakeFeatures = &quot;lakes&quot;eliminatedFeatures = &quot;C:/data/PortlandOutput.gdb/lakes_eliminated&quot;simplifiedFeatures = &quot;C:/data/PortlandOutput.gdb/lakes_simplified&quot;smoothedFeatures = &quot;C:/data/PortlandOutput.gdb/lakes_smoothed&quot;# Eliminate small islands in lake polygons.DM.EliminatePolygonPart(inLakeFeatures, eliminatedFeatures, 100, &quot;OR&quot;, 0, &quot;CONTAINED_ONLY&quot;) # Simplify lake polygons.CA.SimplifyPolygon(eliminatedFeatures, simplifiedFeatures, &quot;POINT_REMOVE&quot;, 50, 200, &quot;RESOLVE_ERRORS&quot;, &quot;KEEP_COLLAPSED_POINTS&quot;, &quot;CHECK&quot;) # Smooth lake polygons.CA.SmoothPolygon(simplifiedFeatures, smoothedFeatures, &quot;PAEK&quot;, 100, &quot;FLAG_ERRORS&quot;) 了解更多要了解更多关于ArcMap的知识请参阅以下链接： desktop.arcgis.com","categories":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/categories/ArcMap/"}],"tags":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/tags/ArcMap/"},{"name":"Polygon","slug":"Polygon","permalink":"http://yxqblog.tk/tags/Polygon/"},{"name":"Gp","slug":"Gp","permalink":"http://yxqblog.tk/tags/Gp/"}]},{"title":"ArcMap面要素处理之消除面部分(EliminatePolygonPart)","slug":"ArcMap-Ploygon-EliminatePart","date":"2017-04-19T16:00:00.000Z","updated":"2018-03-25T07:16:47.434Z","comments":true,"path":"2017/04/20/ArcMap-Ploygon-EliminatePart/","link":"","permalink":"http://yxqblog.tk/2017/04/20/ArcMap-Ploygon-EliminatePart/","excerpt":"","text":"摘要创建一个新的输出要素类，包含从输入面上删除某些指定大小的部分或孔洞所得的要素。 插图 用法 由于可将面洞看作面的一部分，因此可使用此工具删除或填充面洞。如果洞面积小于指定尺寸，则该洞将被消除，并且在输出中填补该空间。删除的洞中的所有部分也都将在输出中被消除。 部分的大小可以指定为面积、百分比或两者的结合。使用条件参数可确定指定部分大小的方式。条件参数 AREA_AND_PERCENT 和 AREA_OR_PERCENT 选项可使用面积和百分比条件来消除部分。 面部分百分比是以要素总外部面积（包括所有洞的面积）的百分比进行计算的。例如，如果某个具有洞的面的面积为 75 平方米，洞的覆盖面积为 25 平方米，则总的面外部面积为 100 平方米。要消除此洞，需要指定大于 25 平方米的面积，或指定大于 25% 的百分比。如果输入为多部分面，则要素的外部面积为所有面部分所覆盖的面积的总和。 对于多部分面，会将各部分的面积与指定面积进行对比。如果某个面部分小于指定的大小，则该部分将在输出中被消除。 如果面要素的所有部分都小于指定的大小，则会在输出中保留最大的部分，而将其他所有部分消除。 语法1EliminatePolygonPart_management (in_features, out_feature_class, &#123;condition&#125;, &#123;part_area&#125;, &#123;part_area_percent&#125;, &#123;part_option&#125;) 参数 说明 数据类型 in_features 其要素将被复制到输出要素类（消除某些部分或洞）的输入要素类或图层。 Feature Layer out_feature_class 包含其余部分的输出面要素类。 Feature Class condition(可选) 指定要消除的部分的确定方式。AREA —面积小于指定值的部分将被消除。PERCENT —总外部面积百分比小于指定值的部分将被消除。AREA_AND_PERCENT —面积和百分比均小于指定值的部分将被消除。只有同时满足面积和百分比两个条件的面部分才会被删除。AREA_OR_PERCENT —面积或百分比小于指定值的部分将被消除。如果面部分满足面积或百分比条件之一，该面将被删除。 String part_area(可选) 消除小于此面积的部分。 Areal Unit part_area_percent(可选) 消除小于此要素总外部面积百分比的部分。 Double part_option(可选) 确定可消除的部分。CONTAINED_ONLY —仅消除完全包含于其他部分的部分。这是默认设置。ANY —可消除任意部分。 Boolean 代码实例消除面部分示例（Python 窗口）以下 Python 窗口脚本演示了如何在即时模式下使用“消除”工具。 1import arcpy from arcpy import env env.workspace = &quot;C:/data&quot; arcpy.EliminatePolygonPart_management(&quot;buildings.shp&quot;, &quot;output.gdb/remaining_buildings&quot;, &quot;AREA&quot;, 10) 消除面部分示例 2（独立脚本）以下独立 Python 脚本演示了如何使用“消除面部分”工具。 123456789# Name: EliminatePolygonPart_Example2.py # Description: Eliminate small islands before simplifying and smoothing lake boundaries # Author: ESRI # Import system modules import arcpy from arcpy import env # Set environment settings env.workspace = &quot;C:/data/Portland.gdb/Hydrography&quot; # Set local variables inLakeFeatures = &quot;lakes&quot; eliminatedFeatures = &quot;lakes_eliminated&quot; simplifiedFeatures = &quot;lakes_simplified&quot; smoothedFeatures = &quot;lakes_smoothed&quot; # Eliminate small islands in lake polygons. arcpy.EliminatePolygonPart_management(inLakeFeatures, eliminatedFeatures, &quot;AREA&quot;, 100, &quot;&quot;, &quot;CONTAINED_ONLY&quot;) # Simplify lake polygons. arcpy.SimplifyPolygon_cartography(eliminatedFeatures, simplifiedFeatures, &quot;POINT_REMOVE&quot;, 50, 200, &quot;RESOLVE_ERRORS&quot;, &quot;KEEP_COLLAPSED_POINTS&quot;) # Smooth lake polygons. arcpy.SmoothPolygon_cartography(simplifiedFeatures, smoothedFeatures, &quot;BEZIER_INTERPOLATION&quot;) 了解更多要了解更多关于ArcMap的知识请参阅以下链接： desktop.arcgis.com","categories":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/categories/ArcMap/"}],"tags":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/tags/ArcMap/"},{"name":"Polygon","slug":"Polygon","permalink":"http://yxqblog.tk/tags/Polygon/"},{"name":"Gp","slug":"Gp","permalink":"http://yxqblog.tk/tags/Gp/"}]},{"title":"ArcMap面要素处理之消除(Eliminate)","slug":"ArcMap-Ploygon-Eliminate","date":"2017-03-23T16:00:00.000Z","updated":"2018-03-25T07:16:51.850Z","comments":true,"path":"2017/03/24/ArcMap-Ploygon-Eliminate/","link":"","permalink":"http://yxqblog.tk/2017/03/24/ArcMap-Ploygon-Eliminate/","excerpt":"","text":"摘要通过将面与具有最大面积或最长公用边界的邻近面合并来消除面。消除通常用于移除叠加操作（如相交或联合）所生成的小的狭长面。 插图 用法 要消除的要素由应用于面图层的选择内容决定。必须在之前的步骤中使用[按属性选择图层]或[按位置选择图层]或者通过查询 ArcMap 中的地图图层来确定选择内容。 通过删除公用边界来仅将所选面与邻近的未选定面进行合并。所选面将不与邻近的选定面合并。 输入图层必须包含选择内容；否则，消除将失败。 排除表达式和排除图层不会相互排斥，可将二者结合使用以对要消除的要素进行全面控制。 语法1Eliminate_management (in_features, out_feature_class, &#123;selection&#125;, &#123;ex_where_clause&#125;, &#123;ex_features&#125;) 参数 说明 数据类型 in_features 其中的面将与邻近面进行合并的图层。 Feature Layer out_feature_class 待创建的要素类。 Feature Class selection(可选) 这些选项可指定将要使用的消除要素的方法。LENGTH —通过删除公用边界将所选面与邻近的未选定面合并。该邻近面的公用边界最长。这是默认设置。AREA —通过删除公用边界将所选面与邻近的未选定面合并。该邻近面的面积最大。 Boolean ex_where_clause(可选) 用于识别不会被更改的要素的 SQL 表达式。 SQL Expression ex_features(可选) 定义不应被消除的面边界（或部分）的输入折线 (polyline)、面要素类或图层。 Feature Layer 代码实例消除示例（Python 窗口）以下 Python 窗口脚本演示了如何在即时模式下使用“消除”工具。 1234567import arcpyarcpy.env.workspace = &quot;C:/data/Portland.gdb/Census&quot;arcpy.MakeFeatureLayer_management(&quot;blockgrp&quot;, &quot;blocklayer&quot;)arcpy.SelectLayerByAttribute_management(&quot;blocklayer&quot;, &quot;NEW_SELECTION&quot;, &apos;&quot;Area_Sq_Miles&quot; &lt; 0.15&apos;)arcpy.Eliminate_management(&quot;blocklayer&quot;, &quot;C:/output/output.gdb/eliminate_output&quot;, &quot;LENGTH&quot;, &apos;&quot;OBJECTID&quot; = 9&apos;) 消除示例 2（独立脚本）以下独立脚本演示了如何使用“消除”工具。12345678910111213141516171819202122232425# Name: Eliminate_Example2.py# Description: Eliminate features based on a selection. # Import system modulesimport arcpy # Set environment settingsarcpy.env.workspace = &quot;C:/data/Portland.gdb/Census&quot; # Set local variablesinFeatures = &quot;blockgrp&quot;tempLayer = &quot;blocklayer&quot;expression = &apos;&quot;Area_Sq_Miles&quot; &lt; 0.15&apos;outFeatureClass = &quot;C:/output/output.gdb/eliminate_output&quot;exclusionExpression = &apos;&quot;OBJECTID&quot; = 9&apos; # Execute MakeFeatureLayerarcpy.MakeFeatureLayer_management(inFeatures, tempLayer) # Execute SelectLayerByAttribute to define features to be eliminatedarcpy.SelectLayerByAttribute_management(tempLayer, &quot;NEW_SELECTION&quot;, expression) # Execute Eliminatearcpy.Eliminate_management(tempLayer, outFeatureClass, &quot;LENGTH&quot;, exclusionExpression) 了解更多要了解更多关于ArcMap的知识请参阅以下链接： desktop.arcgis.com","categories":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/categories/ArcMap/"}],"tags":[{"name":"ArcMap","slug":"ArcMap","permalink":"http://yxqblog.tk/tags/ArcMap/"},{"name":"Polygon","slug":"Polygon","permalink":"http://yxqblog.tk/tags/Polygon/"},{"name":"Gp","slug":"Gp","permalink":"http://yxqblog.tk/tags/Gp/"}]}]}